// this file is auto generated by endoqa kotlin ffi, modify it with caution
package lib.clang

import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator

/**
 *
 * Retrieve the character data associated with the given string.
 */
public fun clang_getCString(string: CXString): Pointer<Byte> =
    `clang_getCString$mh`.invokeExact(string.`$mem`) as MemorySegment

/**
 *
 * Free the given string.
 */
public fun clang_disposeString(string: CXString): Unit = `clang_disposeString$mh`.invokeExact(string.`$mem`) as Unit

/**
 *
 * Free the given string set.
 */
public fun clang_disposeStringSet(`set`: Pointer<CXStringSet>): Unit =
    `clang_disposeStringSet$mh`.invokeExact(`set`) as Unit

/**
 *
 * Return the timestamp for use with Clang's
 * \c -fbuild-session-timestamp= option.
 */
public fun clang_getBuildSessionTimestamp(): ULong =
    (`clang_getBuildSessionTimestamp$mh`.invokeExact() as Long).toULong()

/**
 *
 * Create a \c CXVirtualFileOverlay object.
 * Must be disposed with \c clang_VirtualFileOverlay_dispose().
 *
 * \param options is reserved, always pass 0.
 */
public fun clang_VirtualFileOverlay_create(options: UInt): CXVirtualFileOverlay =
    `clang_VirtualFileOverlay_create$mh`.invokeExact(options.toInt()) as MemorySegment

/**
 *
 * Map an absolute virtual file path to an absolute real one.
 * The virtual path must be canonicalized (not contain "."/"..").
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_VirtualFileOverlay_addFileMapping(
    `$p0`: CXVirtualFileOverlay,
    virtualPath: Pointer<Byte>,
    realPath: Pointer<Byte>,
): CXErrorCode =
    CXErrorCode.fromInt(`clang_VirtualFileOverlay_addFileMapping$mh`.invokeExact(`$p0`, virtualPath, realPath) as Int)

/**
 *
 * Set the case sensitivity for the \c CXVirtualFileOverlay object.
 * The \c CXVirtualFileOverlay object is case-sensitive by default, this
 * option can be used to override the default.
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_VirtualFileOverlay_setCaseSensitivity(`$p0`: CXVirtualFileOverlay, caseSensitive: Int): CXErrorCode =
    CXErrorCode.fromInt(`clang_VirtualFileOverlay_setCaseSensitivity$mh`.invokeExact(`$p0`, caseSensitive) as Int)

/**
 *
 * Write out the \c CXVirtualFileOverlay object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_VirtualFileOverlay_writeToBuffer(
    `$p0`: CXVirtualFileOverlay,
    options: UInt,
    out_buffer_ptr: Pointer<Pointer<Byte>>,
    out_buffer_size: Pointer<UInt>,
): CXErrorCode = CXErrorCode.fromInt(
    `clang_VirtualFileOverlay_writeToBuffer$mh`.invokeExact(
        `$p0`,
        options.toInt(),
        out_buffer_ptr,
        out_buffer_size,
    ) as Int
)

/**
 *
 * free memory allocated by libclang, such as the buffer returned by
 * \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().
 *
 * \param buffer memory pointer to free.
 */
public fun clang_free(buffer: Pointer<Unit>): Unit = `clang_free$mh`.invokeExact(buffer) as Unit

/**
 *
 * Dispose a \c CXVirtualFileOverlay object.
 */
public fun clang_VirtualFileOverlay_dispose(`$p0`: CXVirtualFileOverlay): Unit =
    `clang_VirtualFileOverlay_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Create a \c CXModuleMapDescriptor object.
 * Must be disposed with \c clang_ModuleMapDescriptor_dispose().
 *
 * \param options is reserved, always pass 0.
 */
public fun clang_ModuleMapDescriptor_create(options: UInt): CXModuleMapDescriptor =
    `clang_ModuleMapDescriptor_create$mh`.invokeExact(options.toInt()) as MemorySegment

/**
 *
 * Sets the framework module name that the module.modulemap describes.
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_ModuleMapDescriptor_setFrameworkModuleName(
    `$p0`: CXModuleMapDescriptor,
    name: Pointer<Byte>
): CXErrorCode =
    CXErrorCode.fromInt(`clang_ModuleMapDescriptor_setFrameworkModuleName$mh`.invokeExact(`$p0`, name) as Int)

/**
 *
 * Sets the umbrella header name that the module.modulemap describes.
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_ModuleMapDescriptor_setUmbrellaHeader(`$p0`: CXModuleMapDescriptor, name: Pointer<Byte>): CXErrorCode =
    CXErrorCode.fromInt(`clang_ModuleMapDescriptor_setUmbrellaHeader$mh`.invokeExact(`$p0`, name) as Int)

/**
 *
 * Write out the \c CXModuleMapDescriptor object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */
public fun clang_ModuleMapDescriptor_writeToBuffer(
    `$p0`: CXModuleMapDescriptor,
    options: UInt,
    out_buffer_ptr: Pointer<Pointer<Byte>>,
    out_buffer_size: Pointer<UInt>,
): CXErrorCode = CXErrorCode.fromInt(
    `clang_ModuleMapDescriptor_writeToBuffer$mh`.invokeExact(
        `$p0`,
        options.toInt(),
        out_buffer_ptr,
        out_buffer_size,
    ) as Int
)

/**
 *
 * Dispose a \c CXModuleMapDescriptor object.
 */
public fun clang_ModuleMapDescriptor_dispose(`$p0`: CXModuleMapDescriptor): Unit =
    `clang_ModuleMapDescriptor_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Creates a compilation database from the database found in directory
 * buildDir. For example, CMake can output a compile_commands.json which can
 * be used to build the database.
 *
 * It must be freed by \c clang_CompilationDatabase_dispose.
 */
public fun clang_CompilationDatabase_fromDirectory(
    BuildDir: Pointer<Byte>,
    ErrorCode: Pointer<CXCompilationDatabase_Error>
): CXCompilationDatabase =
    `clang_CompilationDatabase_fromDirectory$mh`.invokeExact(BuildDir, ErrorCode) as MemorySegment

/**
 *
 * Free the given compilation database
 */
public fun clang_CompilationDatabase_dispose(`$p0`: CXCompilationDatabase): Unit =
    `clang_CompilationDatabase_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Find the compile commands used for a file. The compile commands
 * must be freed by \c clang_CompileCommands_dispose.
 */
public fun clang_CompilationDatabase_getCompileCommands(
    `$p0`: CXCompilationDatabase,
    CompleteFileName: Pointer<Byte>
): CXCompileCommands =
    `clang_CompilationDatabase_getCompileCommands$mh`.invokeExact(`$p0`, CompleteFileName) as MemorySegment

/**
 *
 * Get all the compile commands in the given compilation database.
 */
public fun clang_CompilationDatabase_getAllCompileCommands(`$p0`: CXCompilationDatabase): CXCompileCommands =
    `clang_CompilationDatabase_getAllCompileCommands$mh`.invokeExact(`$p0`) as MemorySegment

/**
 *
 * Free the given CompileCommands
 */
public fun clang_CompileCommands_dispose(`$p0`: CXCompileCommands): Unit =
    `clang_CompileCommands_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Get the number of CompileCommand we have for a file
 */
public fun clang_CompileCommands_getSize(`$p0`: CXCompileCommands): UInt =
    (`clang_CompileCommands_getSize$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Get the I'th CompileCommand for a file
 *
 * Note : 0 <= i < clang_CompileCommands_getSize(CXCompileCommands)
 */
public fun clang_CompileCommands_getCommand(`$p0`: CXCompileCommands, I: UInt): CXCompileCommand =
    `clang_CompileCommands_getCommand$mh`.invokeExact(`$p0`, I.toInt()) as MemorySegment

/**
 *
 * Get the working directory where the CompileCommand was executed from
 */
context(SegmentAllocator)
public fun clang_CompileCommand_getDirectory(`$p0`: CXCompileCommand): CXString =
    CXString(`clang_CompileCommand_getDirectory$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Get the filename associated with the CompileCommand.
 */
context(SegmentAllocator)
public fun clang_CompileCommand_getFilename(`$p0`: CXCompileCommand): CXString =
    CXString(`clang_CompileCommand_getFilename$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Get the number of arguments in the compiler invocation.
 */
public fun clang_CompileCommand_getNumArgs(`$p0`: CXCompileCommand): UInt =
    (`clang_CompileCommand_getNumArgs$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Get the I'th argument value in the compiler invocations
 *
 * Invariant :
 * - argument 0 is the compiler executable
 */
context(SegmentAllocator)
public fun clang_CompileCommand_getArg(`$p0`: CXCompileCommand, I: UInt): CXString =
    CXString(`clang_CompileCommand_getArg$mh`.invokeExact(this@SegmentAllocator, `$p0`, I.toInt()) as MemorySegment)

/**
 *
 * Get the number of source mappings for the compiler invocation.
 */
public fun clang_CompileCommand_getNumMappedSources(`$p0`: CXCompileCommand): UInt =
    (`clang_CompileCommand_getNumMappedSources$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Get the I'th mapped source path for the compiler invocation.
 */
context(SegmentAllocator)
public fun clang_CompileCommand_getMappedSourcePath(`$p0`: CXCompileCommand, I: UInt): CXString = CXString(
    `clang_CompileCommand_getMappedSourcePath$mh`.invokeExact(
        this@SegmentAllocator,
        `$p0`,
        I.toInt(),
    ) as MemorySegment
)

/**
 *
 * Get the I'th mapped source content for the compiler invocation.
 */
context(SegmentAllocator)
public fun clang_CompileCommand_getMappedSourceContent(`$p0`: CXCompileCommand, I: UInt): CXString = CXString(
    `clang_CompileCommand_getMappedSourceContent$mh`.invokeExact(
        this@SegmentAllocator,
        `$p0`,
        I.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the complete file and path name of the given file.
 */
context(SegmentAllocator)
public fun clang_getFileName(SFile: CXFile): CXString =
    CXString(`clang_getFileName$mh`.invokeExact(this@SegmentAllocator, SFile) as MemorySegment)

/**
 *
 * Retrieve the last modification time of the given file.
 */
public fun clang_getFileTime(SFile: CXFile): time_t = `clang_getFileTime$mh`.invokeExact(SFile) as Long

/**
 *
 * Retrieve the unique ID for the given \c file.
 *
 * \param file the file to get the ID for.
 * \param outID stores the returned CXFileUniqueID.
 * \returns If there was a failure getting the unique ID, returns non-zero,
 * otherwise returns 0.
 */
public fun clang_getFileUniqueID(`file`: CXFile, outID: Pointer<CXFileUniqueID>): Int =
    `clang_getFileUniqueID$mh`.invokeExact(`file`, outID) as Int

/**
 *
 * Returns non-zero if the \c file1 and \c file2 point to the same file,
 * or they are both NULL.
 */
public fun clang_File_isEqual(file1: CXFile, file2: CXFile): Int =
    `clang_File_isEqual$mh`.invokeExact(file1, file2) as Int

/**
 *
 * Returns the real path name of \c file.
 *
 * An empty string may be returned. Use \c clang_getFileName() in that case.
 */
context(SegmentAllocator)
public fun clang_File_tryGetRealPathName(`file`: CXFile): CXString =
    CXString(`clang_File_tryGetRealPathName$mh`.invokeExact(this@SegmentAllocator, `file`) as MemorySegment)

/**
 *
 * Retrieve a NULL (invalid) source location.
 */
context(SegmentAllocator)
public fun clang_getNullLocation(): CXSourceLocation =
    CXSourceLocation(`clang_getNullLocation$mh`.invokeExact(this@SegmentAllocator) as MemorySegment)

/**
 *
 * Determine whether two source locations, which must refer into
 * the same translation unit, refer to exactly the same point in the source
 * code.
 *
 * \returns non-zero if the source locations refer to the same location, zero
 * if they refer to different locations.
 */
public fun clang_equalLocations(loc1: CXSourceLocation, loc2: CXSourceLocation): UInt =
    (`clang_equalLocations$mh`.invokeExact(loc1.`$mem`, loc2.`$mem`) as Int).toUInt()

/**
 *
 * Returns non-zero if the given source location is in a system header.
 */
public fun clang_Location_isInSystemHeader(location: CXSourceLocation): Int =
    `clang_Location_isInSystemHeader$mh`.invokeExact(location.`$mem`) as Int

/**
 *
 * Returns non-zero if the given source location is in the main file of
 * the corresponding translation unit.
 */
public fun clang_Location_isFromMainFile(location: CXSourceLocation): Int =
    `clang_Location_isFromMainFile$mh`.invokeExact(location.`$mem`) as Int

/**
 *
 * Retrieve a NULL (invalid) source range.
 */
context(SegmentAllocator)
public fun clang_getNullRange(): CXSourceRange =
    CXSourceRange(`clang_getNullRange$mh`.invokeExact(this@SegmentAllocator) as MemorySegment)

/**
 *
 * Retrieve a source range given the beginning and ending source
 * locations.
 */
context(SegmentAllocator)
public fun clang_getRange(begin: CXSourceLocation, end: CXSourceLocation): CXSourceRange =
    CXSourceRange(`clang_getRange$mh`.invokeExact(this@SegmentAllocator, begin.`$mem`, end.`$mem`) as MemorySegment)

/**
 *
 * Determine whether two ranges are equivalent.
 *
 * \returns non-zero if the ranges are the same, zero if they differ.
 */
public fun clang_equalRanges(range1: CXSourceRange, range2: CXSourceRange): UInt =
    (`clang_equalRanges$mh`.invokeExact(range1.`$mem`, range2.`$mem`) as Int).toUInt()

/**
 *
 * Returns non-zero if \p range is null.
 */
public fun clang_Range_isNull(range: CXSourceRange): Int = `clang_Range_isNull$mh`.invokeExact(range.`$mem`) as Int

/**
 *
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public fun clang_getExpansionLocation(
    location: CXSourceLocation,
    `file`: Pointer<CXFile>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
    offset: Pointer<UInt>,
): Unit = `clang_getExpansionLocation$mh`.invokeExact(location.`$mem`, `file`, line, column, offset) as Unit

/**
 *
 * Retrieve the file, line and column represented by the given source
 * location, as specified in a # line directive.
 *
 * Example: given the following source code in a file somefile.c
 *
 * \code
 * #123 "dummy.c" 1
 *
 * static int func(void)
 * {
 * return 0;
 * }
 * \endcode
 *
 * the location information returned by this function would be
 *
 * File: dummy.c Line: 124 Column: 12
 *
 * whereas clang_getExpansionLocation would have returned
 *
 * File: somefile.c Line: 3 Column: 12
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param filename [out] if non-NULL, will be set to the filename of the
 * source location. Note that filenames returned will be for "virtual" files,
 * which don't necessarily exist on the machine running clang - e.g. when
 * parsing preprocessed output obtained from a different environment. If
 * a non-NULL value is passed in, remember to dispose of the returned value
 * using \c clang_disposeString() once you've finished with it. For an invalid
 * source location, an empty string is returned.
 *
 * \param line [out] if non-NULL, will be set to the line number of the
 * source location. For an invalid source location, zero is returned.
 *
 * \param column [out] if non-NULL, will be set to the column number of the
 * source location. For an invalid source location, zero is returned.
 */
public fun clang_getPresumedLocation(
    location: CXSourceLocation,
    filename: Pointer<CXString>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
): Unit = `clang_getPresumedLocation$mh`.invokeExact(location.`$mem`, filename, line, column) as Unit

/**
 *
 * Legacy API to retrieve the file, line, column, and offset represented
 * by the given source location.
 *
 * This interface has been replaced by the newer interface
 * #clang_getExpansionLocation(). See that interface's documentation for
 * details.
 */
public fun clang_getInstantiationLocation(
    location: CXSourceLocation,
    `file`: Pointer<CXFile>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
    offset: Pointer<UInt>,
): Unit = `clang_getInstantiationLocation$mh`.invokeExact(location.`$mem`, `file`, line, column, offset) as Unit

/**
 *
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro instantiation, return where the
 * location was originally spelled in the source file.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public fun clang_getSpellingLocation(
    location: CXSourceLocation,
    `file`: Pointer<CXFile>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
    offset: Pointer<UInt>,
): Unit = `clang_getSpellingLocation$mh`.invokeExact(location.`$mem`, `file`, line, column, offset) as Unit

/**
 *
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, return where the macro was
 * expanded or where the macro argument was written, if the location points at
 * a macro argument.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public fun clang_getFileLocation(
    location: CXSourceLocation,
    `file`: Pointer<CXFile>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
    offset: Pointer<UInt>,
): Unit = `clang_getFileLocation$mh`.invokeExact(location.`$mem`, `file`, line, column, offset) as Unit

/**
 *
 * Retrieve a source location representing the first character within a
 * source range.
 */
context(SegmentAllocator)
public fun clang_getRangeStart(range: CXSourceRange): CXSourceLocation =
    CXSourceLocation(`clang_getRangeStart$mh`.invokeExact(this@SegmentAllocator, range.`$mem`) as MemorySegment)

/**
 *
 * Retrieve a source location representing the last character within a
 * source range.
 */
context(SegmentAllocator)
public fun clang_getRangeEnd(range: CXSourceRange): CXSourceLocation =
    CXSourceLocation(`clang_getRangeEnd$mh`.invokeExact(this@SegmentAllocator, range.`$mem`) as MemorySegment)

/**
 *
 * Destroy the given \c CXSourceRangeList.
 */
public fun clang_disposeSourceRangeList(ranges: Pointer<CXSourceRangeList>): Unit =
    `clang_disposeSourceRangeList$mh`.invokeExact(ranges) as Unit

/**
 *
 * Determine the number of diagnostics in a CXDiagnosticSet.
 */
public fun clang_getNumDiagnosticsInSet(Diags: CXDiagnosticSet): UInt =
    (`clang_getNumDiagnosticsInSet$mh`.invokeExact(Diags) as Int).toUInt()

/**
 *
 * Retrieve a diagnostic associated with the given CXDiagnosticSet.
 *
 * \param Diags the CXDiagnosticSet to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public fun clang_getDiagnosticInSet(Diags: CXDiagnosticSet, Index: UInt): CXDiagnostic =
    `clang_getDiagnosticInSet$mh`.invokeExact(Diags, Index.toInt()) as MemorySegment

/**
 *
 * Deserialize a set of diagnostics from a Clang diagnostics bitcode
 * file.
 *
 * \param file The name of the file to deserialize.
 * \param error A pointer to a enum value recording if there was a problem
 * deserializing the diagnostics.
 * \param errorString A pointer to a CXString for recording the error string
 * if the file was not successfully loaded.
 *
 * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These
 * diagnostics should be released using clang_disposeDiagnosticSet().
 */
public fun clang_loadDiagnostics(
    `file`: Pointer<Byte>,
    error: Pointer<CXLoadDiag_Error>,
    errorString: Pointer<CXString>,
): CXDiagnosticSet = `clang_loadDiagnostics$mh`.invokeExact(`file`, error, errorString) as MemorySegment

/**
 *
 * Release a CXDiagnosticSet and all of its contained diagnostics.
 */
public fun clang_disposeDiagnosticSet(Diags: CXDiagnosticSet): Unit =
    `clang_disposeDiagnosticSet$mh`.invokeExact(Diags) as Unit

/**
 *
 * Retrieve the child diagnostics of a CXDiagnostic.
 *
 * This CXDiagnosticSet does not need to be released by
 * clang_disposeDiagnosticSet.
 */
public fun clang_getChildDiagnostics(D: CXDiagnostic): CXDiagnosticSet =
    `clang_getChildDiagnostics$mh`.invokeExact(D) as MemorySegment

/**
 *
 * Destroy a diagnostic.
 */
public fun clang_disposeDiagnostic(Diagnostic: CXDiagnostic): Unit =
    `clang_disposeDiagnostic$mh`.invokeExact(Diagnostic) as Unit

/**
 *
 * Format the given diagnostic in a manner that is suitable for display.
 *
 * This routine will format the given diagnostic to a string, rendering
 * the diagnostic according to the various options given. The
 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of
 * options that most closely mimics the behavior of the clang compiler.
 *
 * \param Diagnostic The diagnostic to print.
 *
 * \param Options A set of options that control the diagnostic display,
 * created by combining \c CXDiagnosticDisplayOptions values.
 *
 * \returns A new string containing for formatted diagnostic.
 */
context(SegmentAllocator)
public fun clang_formatDiagnostic(Diagnostic: CXDiagnostic, Options: UInt): CXString = CXString(
    `clang_formatDiagnostic$mh`.invokeExact(
        this@SegmentAllocator,
        Diagnostic,
        Options.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the set of display options most similar to the
 * default behavior of the clang compiler.
 *
 * \returns A set of display options suitable for use with \c
 * clang_formatDiagnostic().
 */
public fun clang_defaultDiagnosticDisplayOptions(): UInt =
    (`clang_defaultDiagnosticDisplayOptions$mh`.invokeExact() as Int).toUInt()

/**
 *
 * Determine the severity of the given diagnostic.
 */
public fun clang_getDiagnosticSeverity(`$p0`: CXDiagnostic): CXDiagnosticSeverity =
    CXDiagnosticSeverity.fromInt(`clang_getDiagnosticSeverity$mh`.invokeExact(`$p0`) as Int)

/**
 *
 * Retrieve the source location of the given diagnostic.
 *
 * This location is where Clang would print the caret ('^') when
 * displaying the diagnostic on the command line.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticLocation(`$p0`: CXDiagnostic): CXSourceLocation =
    CXSourceLocation(`clang_getDiagnosticLocation$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Retrieve the text of the given diagnostic.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticSpelling(`$p0`: CXDiagnostic): CXString =
    CXString(`clang_getDiagnosticSpelling$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Retrieve the name of the command-line option that enabled this
 * diagnostic.
 *
 * \param Diag The diagnostic to be queried.
 *
 * \param Disable If non-NULL, will be set to the option that disables this
 * diagnostic (if any).
 *
 * \returns A string that contains the command-line option used to enable this
 * warning, such as "-Wconversion" or "-pedantic".
 */
context(SegmentAllocator)
public fun clang_getDiagnosticOption(Diag: CXDiagnostic, Disable: Pointer<CXString>): CXString =
    CXString(`clang_getDiagnosticOption$mh`.invokeExact(this@SegmentAllocator, Diag, Disable) as MemorySegment)

/**
 *
 * Retrieve the category number for this diagnostic.
 *
 * Diagnostics can be categorized into groups along with other, related
 * diagnostics (e.g., diagnostics under the same warning flag). This routine
 * retrieves the category number for the given diagnostic.
 *
 * \returns The number of the category that contains this diagnostic, or zero
 * if this diagnostic is uncategorized.
 */
public fun clang_getDiagnosticCategory(`$p0`: CXDiagnostic): UInt =
    (`clang_getDiagnosticCategory$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Retrieve the name of a particular diagnostic category.  This
 * is now deprecated.  Use clang_getDiagnosticCategoryText()
 * instead.
 *
 * \param Category A diagnostic category number, as returned by
 * \c clang_getDiagnosticCategory().
 *
 * \returns The name of the given diagnostic category.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticCategoryName(Category: UInt): CXString = CXString(
    `clang_getDiagnosticCategoryName$mh`.invokeExact(
        this@SegmentAllocator,
        Category.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the diagnostic category text for a given diagnostic.
 *
 * \returns The text of the given diagnostic category.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticCategoryText(`$p0`: CXDiagnostic): CXString =
    CXString(`clang_getDiagnosticCategoryText$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Determine the number of source ranges associated with the given
 * diagnostic.
 */
public fun clang_getDiagnosticNumRanges(`$p0`: CXDiagnostic): UInt =
    (`clang_getDiagnosticNumRanges$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Retrieve a source range associated with the diagnostic.
 *
 * A diagnostic's source ranges highlight important elements in the source
 * code. On the command line, Clang displays source ranges by
 * underlining them with '~' characters.
 *
 * \param Diagnostic the diagnostic whose range is being extracted.
 *
 * \param Range the zero-based index specifying which range to
 *
 * \returns the requested source range.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticRange(Diagnostic: CXDiagnostic, Range: UInt): CXSourceRange = CXSourceRange(
    `clang_getDiagnosticRange$mh`.invokeExact(
        this@SegmentAllocator,
        Diagnostic,
        Range.toInt(),
    ) as MemorySegment
)

/**
 *
 * Determine the number of fix-it hints associated with the
 * given diagnostic.
 */
public fun clang_getDiagnosticNumFixIts(Diagnostic: CXDiagnostic): UInt =
    (`clang_getDiagnosticNumFixIts$mh`.invokeExact(Diagnostic) as Int).toUInt()

/**
 *
 * Retrieve the replacement information for a given fix-it.
 *
 * Fix-its are described in terms of a source range whose contents
 * should be replaced by a string. This approach generalizes over
 * three kinds of operations: removal of source code (the range covers
 * the code to be removed and the replacement string is empty),
 * replacement of source code (the range covers the code to be
 * replaced and the replacement string provides the new code), and
 * insertion (both the start and end of the range point at the
 * insertion location, and the replacement string provides the text to
 * insert).
 *
 * \param Diagnostic The diagnostic whose fix-its are being queried.
 *
 * \param FixIt The zero-based index of the fix-it.
 *
 * \param ReplacementRange The source range whose contents will be
 * replaced with the returned replacement string. Note that source
 * ranges are half-open ranges [a, b), so the source code should be
 * replaced from a and up to (but not including) b.
 *
 * \returns A string containing text that should be replace the source
 * code indicated by the \c ReplacementRange.
 */
context(SegmentAllocator)
public fun clang_getDiagnosticFixIt(
    Diagnostic: CXDiagnostic,
    FixIt: UInt,
    ReplacementRange: Pointer<CXSourceRange>,
): CXString = CXString(
    `clang_getDiagnosticFixIt$mh`.invokeExact(
        this@SegmentAllocator,
        Diagnostic,
        FixIt.toInt(),
        ReplacementRange,
    ) as MemorySegment
)

/**
 *
 * Provides a shared context for creating translation units.
 *
 * It provides two options:
 *
 * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
 * declarations (when loading any new translation units). A "local" declaration
 * is one that belongs in the translation unit itself and not in a precompiled
 * header that was used by the translation unit. If zero, all declarations
 * will be enumerated.
 *
 * Here is an example:
 *
 * \code
 * // excludeDeclsFromPCH = 1, displayDiagnostics=1
 * Idx = clang_createIndex(1, 1);
 *
 * // IndexTest.pch was produced with the following command:
 * // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
 * TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
 *
 * // This will load all the symbols from 'IndexTest.pch'
 * clang_visitChildren(clang_getTranslationUnitCursor(TU),
 * TranslationUnitVisitor, 0);
 * clang_disposeTranslationUnit(TU);
 *
 * // This will load all the symbols from 'IndexTest.c', excluding symbols
 * // from 'IndexTest.pch'.
 * char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
 * TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
 * 0, 0);
 * clang_visitChildren(clang_getTranslationUnitCursor(TU),
 * TranslationUnitVisitor, 0);
 * clang_disposeTranslationUnit(TU);
 * \endcode
 *
 * This process of creating the 'pch', loading it separately, and using it (via
 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
 * (which gives the indexer the same performance benefit as the compiler).
 */
public fun clang_createIndex(excludeDeclarationsFromPCH: Int, displayDiagnostics: Int): CXIndex =
    `clang_createIndex$mh`.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics) as MemorySegment

/**
 *
 * Destroy the given index.
 *
 * The index must not be destroyed until all of the translation units created
 * within that index have been destroyed.
 */
public fun clang_disposeIndex(index: CXIndex): Unit = `clang_disposeIndex$mh`.invokeExact(index) as Unit

/**
 *
 * Provides a shared context for creating translation units.
 *
 * Call this function instead of clang_createIndex() if you need to configure
 * the additional options in CXIndexOptions.
 *
 * \returns The created index or null in case of error, such as an unsupported
 * value of options->Size.
 *
 * For example:
 * \code
 * CXIndex createIndex(const char *ApplicationTemporaryPath) {
 * const int ExcludeDeclarationsFromPCH = 1;
 * const int DisplayDiagnostics = 1;
 * CXIndex Idx;
 * #if CINDEX_VERSION_MINOR >= 64
 * CXIndexOptions Opts;
 * memset(&Opts, 0, sizeof(Opts));
 * Opts.Size = sizeof(CXIndexOptions);
 * Opts.ThreadBackgroundPriorityForIndexing = 1;
 * Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;
 * Opts.DisplayDiagnostics = DisplayDiagnostics;
 * Opts.PreambleStoragePath = ApplicationTemporaryPath;
 * Idx = clang_createIndexWithOptions(&Opts);
 * if (Idx)
 * return Idx;
 * fprintf(stderr,
 * "clang_createIndexWithOptions() failed. "
 * "CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n",
 * CINDEX_VERSION_MINOR, Opts.Size);
 * #else
 * (void)ApplicationTemporaryPath;
 * #endif
 * Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);
 * clang_CXIndex_setGlobalOptions(
 * Idx, clang_CXIndex_getGlobalOptions(Idx) |
 * CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 * return Idx;
 * }
 * \endcode
 *
 * \sa clang_createIndex()
 */
public fun clang_createIndexWithOptions(options: Pointer<CXIndexOptions>): CXIndex =
    `clang_createIndexWithOptions$mh`.invokeExact(options) as MemorySegment

/**
 *
 * Sets general options associated with a CXIndex.
 *
 * This function is DEPRECATED. Set
 * CXIndexOptions::ThreadBackgroundPriorityForIndexing and/or
 * CXIndexOptions::ThreadBackgroundPriorityForEditing and call
 * clang_createIndexWithOptions() instead.
 *
 * For example:
 * \code
 * CXIndex idx = ...;
 * clang_CXIndex_setGlobalOptions(idx,
 * clang_CXIndex_getGlobalOptions(idx) |
 * CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 * \endcode
 *
 * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
 */
public fun clang_CXIndex_setGlobalOptions(`$p0`: CXIndex, options: UInt): Unit =
    `clang_CXIndex_setGlobalOptions$mh`.invokeExact(`$p0`, options.toInt()) as Unit

/**
 *
 * Gets the general options associated with a CXIndex.
 *
 * This function allows to obtain the final option values used by libclang after
 * specifying the option policies via CXChoice enumerators.
 *
 * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
 * are associated with the given CXIndex object.
 */
public fun clang_CXIndex_getGlobalOptions(`$p0`: CXIndex): UInt =
    (`clang_CXIndex_getGlobalOptions$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Sets the invocation emission path option in a CXIndex.
 *
 * This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and
 * call clang_createIndexWithOptions() instead.
 *
 * The invocation emission path specifies a path which will contain log
 * files for certain libclang invocations. A null value (default) implies that
 * libclang invocations are not logged..
 */
public fun clang_CXIndex_setInvocationEmissionPathOption(`$p0`: CXIndex, Path: Pointer<Byte>): Unit =
    `clang_CXIndex_setInvocationEmissionPathOption$mh`.invokeExact(`$p0`, Path) as Unit

/**
 *
 * Determine whether the given header is guarded against
 * multiple inclusions, either with the conventional
 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.
 */
public fun clang_isFileMultipleIncludeGuarded(tu: CXTranslationUnit, `file`: CXFile): UInt =
    (`clang_isFileMultipleIncludeGuarded$mh`.invokeExact(tu, `file`) as Int).toUInt()

/**
 *
 * Retrieve a file handle within the given translation unit.
 *
 * \param tu the translation unit
 *
 * \param file_name the name of the file.
 *
 * \returns the file handle for the named file in the translation unit \p tu,
 * or a NULL file handle if the file was not a part of this translation unit.
 */
public fun clang_getFile(tu: CXTranslationUnit, file_name: Pointer<Byte>): CXFile =
    `clang_getFile$mh`.invokeExact(tu, file_name) as MemorySegment

/**
 *
 * Retrieve the buffer associated with the given file.
 *
 * \param tu the translation unit
 *
 * \param file the file for which to retrieve the buffer.
 *
 * \param size [out] if non-NULL, will be set to the size of the buffer.
 *
 * \returns a pointer to the buffer in memory that holds the contents of
 * \p file, or a NULL pointer when the file is not loaded.
 */
public fun clang_getFileContents(
    tu: CXTranslationUnit,
    `file`: CXFile,
    size: Pointer<ULong>,
): Pointer<Byte> = `clang_getFileContents$mh`.invokeExact(tu, `file`, size) as MemorySegment

/**
 *
 * Retrieves the source location associated with a given file/line/column
 * in a particular translation unit.
 */
context(SegmentAllocator)
public fun clang_getLocation(
    tu: CXTranslationUnit,
    `file`: CXFile,
    line: UInt,
    column: UInt,
): CXSourceLocation = CXSourceLocation(
    `clang_getLocation$mh`.invokeExact(
        this@SegmentAllocator,
        tu,
        `file`,
        line.toInt(),
        column.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieves the source location associated with a given character offset
 * in a particular translation unit.
 */
context(SegmentAllocator)
public fun clang_getLocationForOffset(
    tu: CXTranslationUnit,
    `file`: CXFile,
    offset: UInt,
): CXSourceLocation = CXSourceLocation(
    `clang_getLocationForOffset$mh`.invokeExact(
        this@SegmentAllocator,
        tu,
        `file`,
        offset.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve all ranges that were skipped by the preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */
public fun clang_getSkippedRanges(tu: CXTranslationUnit, `file`: CXFile): Pointer<CXSourceRangeList> =
    `clang_getSkippedRanges$mh`.invokeExact(tu, `file`) as MemorySegment

/**
 *
 * Retrieve all ranges from all files that were skipped by the
 * preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */
public fun clang_getAllSkippedRanges(tu: CXTranslationUnit): Pointer<CXSourceRangeList> =
    `clang_getAllSkippedRanges$mh`.invokeExact(tu) as MemorySegment

/**
 *
 * Determine the number of diagnostics produced for the given
 * translation unit.
 */
public fun clang_getNumDiagnostics(Unit: CXTranslationUnit): UInt =
    (`clang_getNumDiagnostics$mh`.invokeExact(Unit) as Int).toUInt()

/**
 *
 * Retrieve a diagnostic associated with the given translation unit.
 *
 * \param Unit the translation unit to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public fun clang_getDiagnostic(Unit: CXTranslationUnit, Index: UInt): CXDiagnostic =
    `clang_getDiagnostic$mh`.invokeExact(Unit, Index.toInt()) as MemorySegment

/**
 *
 * Retrieve the complete set of diagnostics associated with a
 * translation unit.
 *
 * \param Unit the translation unit to query.
 */
public fun clang_getDiagnosticSetFromTU(Unit: CXTranslationUnit): CXDiagnosticSet =
    `clang_getDiagnosticSetFromTU$mh`.invokeExact(Unit) as MemorySegment

/**
 *
 * Get the original translation unit source file name.
 */
context(SegmentAllocator)
public fun clang_getTranslationUnitSpelling(CTUnit: CXTranslationUnit): CXString =
    CXString(`clang_getTranslationUnitSpelling$mh`.invokeExact(this@SegmentAllocator, CTUnit) as MemorySegment)

/**
 *
 * Return the CXTranslationUnit for a given source file and the provided
 * command line arguments one would pass to the compiler.
 *
 * Note: The 'source_filename' argument is optional.  If the caller provides a
 * NULL pointer, the name of the source file is expected to reside in the
 * specified command line arguments.
 *
 * Note: When encountered in 'clang_command_line_args', the following options
 * are ignored:
 *
 * '-c'
 * '-emit-ast'
 * '-fsyntax-only'
 * '-o \<output file>'  (both '-o' and '\<output file>' are ignored)
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \p clang_command_line_args.
 *
 * \param num_clang_command_line_args The number of command-line arguments in
 * \p clang_command_line_args.
 *
 * \param clang_command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for code completion, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 */
public fun clang_createTranslationUnitFromSourceFile(
    CIdx: CXIndex,
    source_filename: Pointer<Byte>,
    num_clang_command_line_args: Int,
    clang_command_line_args: Pointer<Pointer<Byte>>,
    num_unsaved_files: UInt,
    unsaved_files: Pointer<CXUnsavedFile>,
): CXTranslationUnit = `clang_createTranslationUnitFromSourceFile$mh`.invokeExact(
    CIdx,
    source_filename,
    num_clang_command_line_args,
    clang_command_line_args,
    num_unsaved_files.toInt(),
    unsaved_files,
) as MemorySegment

/**
 *
 * Same as \c clang_createTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
public fun clang_createTranslationUnit(CIdx: CXIndex, ast_filename: Pointer<Byte>): CXTranslationUnit =
    `clang_createTranslationUnit$mh`.invokeExact(CIdx, ast_filename) as MemorySegment

/**
 *
 * Create a translation unit from an AST file (\c -emit-ast).
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
public fun clang_createTranslationUnit2(
    CIdx: CXIndex,
    ast_filename: Pointer<Byte>,
    out_TU: Pointer<CXTranslationUnit>,
): CXErrorCode = CXErrorCode.fromInt(`clang_createTranslationUnit2$mh`.invokeExact(CIdx, ast_filename, out_TU) as Int)

/**
 *
 * Returns the set of flags that is suitable for parsing a translation
 * unit that is being edited.
 *
 * The set of flags returned provide options for \c clang_parseTranslationUnit()
 * to indicate that the translation unit is likely to be reparsed many times,
 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly
 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag
 * set contains an unspecified set of optimizations (e.g., the precompiled
 * preamble) geared toward improving the performance of these routines. The
 * set of optimizations enabled may change from one version to the next.
 */
public fun clang_defaultEditingTranslationUnitOptions(): UInt =
    (`clang_defaultEditingTranslationUnitOptions$mh`.invokeExact() as Int).toUInt()

/**
 *
 * Same as \c clang_parseTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
public fun clang_parseTranslationUnit(
    CIdx: CXIndex,
    source_filename: Pointer<Byte>,
    command_line_args: Pointer<Pointer<Byte>>,
    num_command_line_args: Int,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    options: UInt,
): CXTranslationUnit = `clang_parseTranslationUnit$mh`.invokeExact(
    CIdx,
    source_filename,
    command_line_args,
    num_command_line_args,
    unsaved_files,
    num_unsaved_files.toInt(),
    options.toInt(),
) as MemorySegment

/**
 *
 * Parse the given source file and the translation unit corresponding
 * to that file.
 *
 * This routine is the main entry point for the Clang C API, providing the
 * ability to parse a source file into a translation unit that can then be
 * queried by other functions in the API. This routine accepts a set of
 * command-line arguments so that the compilation can be configured in the same
 * way that the compiler is configured on the command line.
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \c command_line_args.
 *
 * \param command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_command_line_args The number of command-line arguments in
 * \c command_line_args.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is managed but not its compilation. This should be a bitwise OR of the
 * CXTranslationUnit_XXX flags.
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit, describing the parsed code and containing any
 * diagnostics produced by the compiler.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
public fun clang_parseTranslationUnit2(
    CIdx: CXIndex,
    source_filename: Pointer<Byte>,
    command_line_args: Pointer<Pointer<Byte>>,
    num_command_line_args: Int,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    options: UInt,
    out_TU: Pointer<CXTranslationUnit>,
): CXErrorCode = CXErrorCode.fromInt(
    `clang_parseTranslationUnit2$mh`.invokeExact(
        CIdx,
        source_filename,
        command_line_args,
        num_command_line_args,
        unsaved_files,
        num_unsaved_files.toInt(),
        options.toInt(),
        out_TU,
    ) as Int
)

/**
 *
 * Same as clang_parseTranslationUnit2 but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */
public fun clang_parseTranslationUnit2FullArgv(
    CIdx: CXIndex,
    source_filename: Pointer<Byte>,
    command_line_args: Pointer<Pointer<Byte>>,
    num_command_line_args: Int,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    options: UInt,
    out_TU: Pointer<CXTranslationUnit>,
): CXErrorCode = CXErrorCode.fromInt(
    `clang_parseTranslationUnit2FullArgv$mh`.invokeExact(
        CIdx,
        source_filename,
        command_line_args,
        num_command_line_args,
        unsaved_files,
        num_unsaved_files.toInt(),
        options.toInt(),
        out_TU,
    ) as Int
)

/**
 *
 * Returns the set of flags that is suitable for saving a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_saveTranslationUnit() by default. The returned flag
 * set contains an unspecified set of options that save translation units with
 * the most commonly-requested data.
 */
public fun clang_defaultSaveOptions(TU: CXTranslationUnit): UInt =
    (`clang_defaultSaveOptions$mh`.invokeExact(TU) as Int).toUInt()

/**
 *
 * Saves a translation unit into a serialized representation of
 * that translation unit on disk.
 *
 * Any translation unit that was parsed without error can be saved
 * into a file. The translation unit can then be deserialized into a
 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,
 * if it is an incomplete translation unit that corresponds to a
 * header, used as a precompiled header when parsing other translation
 * units.
 *
 * \param TU The translation unit to save.
 *
 * \param FileName The file to which the translation unit will be saved.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is saved. This should be a bitwise OR of the
 * CXSaveTranslationUnit_XXX flags.
 *
 * \returns A value that will match one of the enumerators of the CXSaveError
 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was
 * saved successfully, while a non-zero value indicates that a problem occurred.
 */
public fun clang_saveTranslationUnit(
    TU: CXTranslationUnit,
    FileName: Pointer<Byte>,
    options: UInt,
): Int = `clang_saveTranslationUnit$mh`.invokeExact(TU, FileName, options.toInt()) as Int

/**
 *
 * Suspend a translation unit in order to free memory associated with it.
 *
 * A suspended translation unit uses significantly less memory but on the other
 * side does not support any other calls than \c clang_reparseTranslationUnit
 * to resume it or \c clang_disposeTranslationUnit to dispose it completely.
 */
public fun clang_suspendTranslationUnit(`$p0`: CXTranslationUnit): UInt =
    (`clang_suspendTranslationUnit$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Destroy the specified CXTranslationUnit object.
 */
public fun clang_disposeTranslationUnit(`$p0`: CXTranslationUnit): Unit =
    `clang_disposeTranslationUnit$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Returns the set of flags that is suitable for reparsing a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_reparseTranslationUnit() by default. The returned flag
 * set contains an unspecified set of optimizations geared toward common uses
 * of reparsing. The set of optimizations enabled may change from one version
 * to the next.
 */
public fun clang_defaultReparseOptions(TU: CXTranslationUnit): UInt =
    (`clang_defaultReparseOptions$mh`.invokeExact(TU) as Int).toUInt()

/**
 *
 * Reparse the source files that produced this translation unit.
 *
 * This routine can be used to re-parse the source files that originally
 * created the given translation unit, for example because those source files
 * have changed (either on disk or as passed via \p unsaved_files). The
 * source code will be reparsed with the same command-line options as it
 * was originally parsed.
 *
 * Reparsing a translation unit invalidates all cursors and source locations
 * that refer into that translation unit. This makes reparsing a translation
 * unit semantically equivalent to destroying the translation unit and then
 * creating a new translation unit with the same command-line arguments.
 * However, it may be more efficient to reparse a translation
 * unit using this routine.
 *
 * \param TU The translation unit whose contents will be re-parsed. The
 * translation unit must originally have been built with
 * \c clang_createTranslationUnitFromSourceFile().
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files The files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param options A bitset of options composed of the flags in CXReparse_Flags.
 * The function \c clang_defaultReparseOptions() produces a default set of
 * options recommended for most uses, based on the translation unit.
 *
 * \returns 0 if the sources could be reparsed.  A non-zero error code will be
 * returned if reparsing was impossible, such that the translation unit is
 * invalid. In such cases, the only valid call for \c TU is
 * \c clang_disposeTranslationUnit(TU).  The error codes returned by this
 * routine are described by the \c CXErrorCode enum.
 */
public fun clang_reparseTranslationUnit(
    TU: CXTranslationUnit,
    num_unsaved_files: UInt,
    unsaved_files: Pointer<CXUnsavedFile>,
    options: UInt,
): Int =
    `clang_reparseTranslationUnit$mh`.invokeExact(TU, num_unsaved_files.toInt(), unsaved_files, options.toInt()) as Int

/**
 *
 * Returns the human-readable null-terminated C string that represents
 * the name of the memory category.  This string should never be freed.
 */
public fun clang_getTUResourceUsageName(kind: CXTUResourceUsageKind): Pointer<Byte> =
    `clang_getTUResourceUsageName$mh`.invokeExact(kind.value) as MemorySegment

/**
 *
 * Return the memory usage of a translation unit.  This object
 * should be released with clang_disposeCXTUResourceUsage().
 */
context(SegmentAllocator)
public fun clang_getCXTUResourceUsage(TU: CXTranslationUnit): CXTUResourceUsage =
    CXTUResourceUsage(`clang_getCXTUResourceUsage$mh`.invokeExact(this@SegmentAllocator, TU) as MemorySegment)

public fun clang_disposeCXTUResourceUsage(usage: CXTUResourceUsage): Unit =
    `clang_disposeCXTUResourceUsage$mh`.invokeExact(usage.`$mem`) as Unit

/**
 *
 * Get target information for this translation unit.
 *
 * The CXTargetInfo object cannot outlive the CXTranslationUnit object.
 */
public fun clang_getTranslationUnitTargetInfo(CTUnit: CXTranslationUnit): CXTargetInfo =
    `clang_getTranslationUnitTargetInfo$mh`.invokeExact(CTUnit) as MemorySegment

/**
 *
 * Destroy the CXTargetInfo object.
 */
public fun clang_TargetInfo_dispose(Info: CXTargetInfo): Unit = `clang_TargetInfo_dispose$mh`.invokeExact(Info) as Unit

/**
 *
 * Get the normalized target triple as a string.
 *
 * Returns the empty string in case of any error.
 */
context(SegmentAllocator)
public fun clang_TargetInfo_getTriple(Info: CXTargetInfo): CXString =
    CXString(`clang_TargetInfo_getTriple$mh`.invokeExact(this@SegmentAllocator, Info) as MemorySegment)

/**
 *
 * Get the pointer width of the target in bits.
 *
 * Returns -1 in case of error.
 */
public fun clang_TargetInfo_getPointerWidth(Info: CXTargetInfo): Int =
    `clang_TargetInfo_getPointerWidth$mh`.invokeExact(Info) as Int

/**
 *
 * Retrieve the NULL cursor, which represents no entity.
 */
context(SegmentAllocator)
public fun clang_getNullCursor(): CXCursor =
    CXCursor(`clang_getNullCursor$mh`.invokeExact(this@SegmentAllocator) as MemorySegment)

/**
 *
 * Retrieve the cursor that represents the given translation unit.
 *
 * The translation unit cursor can be used to start traversing the
 * various declarations within the given translation unit.
 */
context(SegmentAllocator)
public fun clang_getTranslationUnitCursor(`$p0`: CXTranslationUnit): CXCursor =
    CXCursor(`clang_getTranslationUnitCursor$mh`.invokeExact(this@SegmentAllocator, `$p0`) as MemorySegment)

/**
 *
 * Determine whether two cursors are equivalent.
 */
public fun clang_equalCursors(`$p0`: CXCursor, `$p1`: CXCursor): UInt =
    (`clang_equalCursors$mh`.invokeExact(`$p0`.`$mem`, `$p1`.`$mem`) as Int).toUInt()

/**
 *
 * Returns non-zero if \p cursor is null.
 */
public fun clang_Cursor_isNull(cursor: CXCursor): Int = `clang_Cursor_isNull$mh`.invokeExact(cursor.`$mem`) as Int

/**
 *
 * Compute a hash value for the given cursor.
 */
public fun clang_hashCursor(`$p0`: CXCursor): UInt = (`clang_hashCursor$mh`.invokeExact(`$p0`.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the kind of the given cursor.
 */
public fun clang_getCursorKind(`$p0`: CXCursor): CXCursorKind =
    CXCursorKind.fromInt(`clang_getCursorKind$mh`.invokeExact(`$p0`.`$mem`) as Int)

/**
 *
 * Determine whether the given cursor kind represents a declaration.
 */
public fun clang_isDeclaration(`$p0`: CXCursorKind): UInt =
    (`clang_isDeclaration$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given declaration is invalid.
 *
 * A declaration is invalid if it could not be parsed successfully.
 *
 * \returns non-zero if the cursor represents a declaration and it is
 * invalid, otherwise NULL.
 */
public fun clang_isInvalidDeclaration(`$p0`: CXCursor): UInt =
    (`clang_isInvalidDeclaration$mh`.invokeExact(`$p0`.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents a simple
 * reference.
 *
 * Note that other kinds of cursors (such as expressions) can also refer to
 * other cursors. Use clang_getCursorReferenced() to determine whether a
 * particular cursor refers to another entity.
 */
public fun clang_isReference(`$p0`: CXCursorKind): UInt =
    (`clang_isReference$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents an expression.
 */
public fun clang_isExpression(`$p0`: CXCursorKind): UInt =
    (`clang_isExpression$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents a statement.
 */
public fun clang_isStatement(`$p0`: CXCursorKind): UInt =
    (`clang_isStatement$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents an attribute.
 */
public fun clang_isAttribute(`$p0`: CXCursorKind): UInt =
    (`clang_isAttribute$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given cursor has any attributes.
 */
public fun clang_Cursor_hasAttrs(C: CXCursor): UInt =
    (`clang_Cursor_hasAttrs$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents an invalid
 * cursor.
 */
public fun clang_isInvalid(`$p0`: CXCursorKind): UInt = (`clang_isInvalid$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine whether the given cursor kind represents a translation
 * unit.
 */
public fun clang_isTranslationUnit(`$p0`: CXCursorKind): UInt =
    (`clang_isTranslationUnit$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 * *
 * Determine whether the given cursor represents a preprocessing
 * element, such as a preprocessor directive or macro instantiation.
 */
public fun clang_isPreprocessing(`$p0`: CXCursorKind): UInt =
    (`clang_isPreprocessing$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 * *
 * Determine whether the given cursor represents a currently
 * unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
 */
public fun clang_isUnexposed(`$p0`: CXCursorKind): UInt =
    (`clang_isUnexposed$mh`.invokeExact(`$p0`.value) as Int).toUInt()

/**
 *
 * Determine the linkage of the entity referred to by a given cursor.
 */
public fun clang_getCursorLinkage(cursor: CXCursor): CXLinkageKind =
    CXLinkageKind.fromInt(`clang_getCursorLinkage$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Describe the visibility of the entity referred to by a cursor.
 *
 * This returns the default visibility if not explicitly specified by
 * a visibility attribute. The default visibility may be changed by
 * commandline arguments.
 *
 * \param cursor The cursor to query.
 *
 * \returns The visibility of the cursor.
 */
public fun clang_getCursorVisibility(cursor: CXCursor): CXVisibilityKind =
    CXVisibilityKind.fromInt(`clang_getCursorVisibility$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Determine the availability of the entity that this cursor refers to,
 * taking the current target platform into account.
 *
 * \param cursor The cursor to query.
 *
 * \returns The availability of the cursor.
 */
public fun clang_getCursorAvailability(cursor: CXCursor): CXAvailabilityKind =
    CXAvailabilityKind.fromInt(`clang_getCursorAvailability$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Determine the availability of the entity that this cursor refers to
 * on any platforms for which availability information is known.
 *
 * \param cursor The cursor to query.
 *
 * \param always_deprecated If non-NULL, will be set to indicate whether the
 * entity is deprecated on all platforms.
 *
 * \param deprecated_message If non-NULL, will be set to the message text
 * provided along with the unconditional deprecation of this entity. The client
 * is responsible for deallocating this string.
 *
 * \param always_unavailable If non-NULL, will be set to indicate whether the
 * entity is unavailable on all platforms.
 *
 * \param unavailable_message If non-NULL, will be set to the message text
 * provided along with the unconditional unavailability of this entity. The
 * client is responsible for deallocating this string.
 *
 * \param availability If non-NULL, an array of CXPlatformAvailability instances
 * that will be populated with platform availability information, up to either
 * the number of platforms for which availability information is available (as
 * returned by this function) or \c availability_size, whichever is smaller.
 *
 * \param availability_size The number of elements available in the
 * \c availability array.
 *
 * \returns The number of platforms (N) for which availability information is
 * available (which is unrelated to \c availability_size).
 *
 * Note that the client is responsible for calling
 * \c clang_disposeCXPlatformAvailability to free each of the
 * platform-availability structures returned. There are
 * \c min(N, availability_size) such structures.
 */
public fun clang_getCursorPlatformAvailability(
    cursor: CXCursor,
    always_deprecated: Pointer<Int>,
    deprecated_message: Pointer<CXString>,
    always_unavailable: Pointer<Int>,
    unavailable_message: Pointer<CXString>,
    availability: Pointer<CXPlatformAvailability>,
    availability_size: Int,
): Int = `clang_getCursorPlatformAvailability$mh`.invokeExact(
    cursor.`$mem`,
    always_deprecated,
    deprecated_message,
    always_unavailable,
    unavailable_message,
    availability,
    availability_size,
) as Int

/**
 *
 * Free the memory associated with a \c CXPlatformAvailability structure.
 */
public fun clang_disposeCXPlatformAvailability(availability: Pointer<CXPlatformAvailability>): Unit =
    `clang_disposeCXPlatformAvailability$mh`.invokeExact(availability) as Unit

/**
 *
 * If cursor refers to a variable declaration and it has initializer returns
 * cursor referring to the initializer otherwise return null cursor.
 */
context(SegmentAllocator)
public fun clang_Cursor_getVarDeclInitializer(cursor: CXCursor): CXCursor = CXCursor(
    `clang_Cursor_getVarDeclInitializer$mh`.invokeExact(
        this@SegmentAllocator,
        cursor.`$mem`,
    ) as MemorySegment
)

/**
 *
 * If cursor refers to a variable declaration that has global storage returns 1.
 * If cursor refers to a variable declaration that doesn't have global storage
 * returns 0. Otherwise returns -1.
 */
public fun clang_Cursor_hasVarDeclGlobalStorage(cursor: CXCursor): Int =
    `clang_Cursor_hasVarDeclGlobalStorage$mh`.invokeExact(cursor.`$mem`) as Int

/**
 *
 * If cursor refers to a variable declaration that has external storage
 * returns 1. If cursor refers to a variable declaration that doesn't have
 * external storage returns 0. Otherwise returns -1.
 */
public fun clang_Cursor_hasVarDeclExternalStorage(cursor: CXCursor): Int =
    `clang_Cursor_hasVarDeclExternalStorage$mh`.invokeExact(cursor.`$mem`) as Int

/**
 *
 * Determine the "language" of the entity referred to by a given cursor.
 */
public fun clang_getCursorLanguage(cursor: CXCursor): CXLanguageKind =
    CXLanguageKind.fromInt(`clang_getCursorLanguage$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Determine the "thread-local storage (TLS) kind" of the declaration
 * referred to by a cursor.
 */
public fun clang_getCursorTLSKind(cursor: CXCursor): CXTLSKind =
    CXTLSKind.fromInt(`clang_getCursorTLSKind$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Returns the translation unit that a cursor originated from.
 */
public fun clang_Cursor_getTranslationUnit(`$p0`: CXCursor): CXTranslationUnit =
    `clang_Cursor_getTranslationUnit$mh`.invokeExact(`$p0`.`$mem`) as MemorySegment

/**
 *
 * Creates an empty CXCursorSet.
 */
public fun clang_createCXCursorSet(): CXCursorSet = `clang_createCXCursorSet$mh`.invokeExact() as MemorySegment

/**
 *
 * Disposes a CXCursorSet and releases its associated memory.
 */
public fun clang_disposeCXCursorSet(cset: CXCursorSet): Unit = `clang_disposeCXCursorSet$mh`.invokeExact(cset) as Unit

/**
 *
 * Queries a CXCursorSet to see if it contains a specific CXCursor.
 *
 * \returns non-zero if the set contains the specified cursor.
 */
public fun clang_CXCursorSet_contains(cset: CXCursorSet, cursor: CXCursor): UInt =
    (`clang_CXCursorSet_contains$mh`.invokeExact(cset, cursor.`$mem`) as Int).toUInt()

/**
 *
 * Inserts a CXCursor into a CXCursorSet.
 *
 * \returns zero if the CXCursor was already in the set, and non-zero otherwise.
 */
public fun clang_CXCursorSet_insert(cset: CXCursorSet, cursor: CXCursor): UInt =
    (`clang_CXCursorSet_insert$mh`.invokeExact(cset, cursor.`$mem`) as Int).toUInt()

/**
 *
 * Determine the semantic parent of the given cursor.
 *
 * The semantic parent of a cursor is the cursor that semantically contains
 * the given \p cursor. For many declarations, the lexical and semantic parents
 * are equivalent (the lexical parent is returned by
 * \c clang_getCursorLexicalParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 * void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For global declarations, the semantic parent is the translation unit.
 */
context(SegmentAllocator)
public fun clang_getCursorSemanticParent(cursor: CXCursor): CXCursor =
    CXCursor(`clang_getCursorSemanticParent$mh`.invokeExact(this@SegmentAllocator, cursor.`$mem`) as MemorySegment)

/**
 *
 * Determine the lexical parent of the given cursor.
 *
 * The lexical parent of a cursor is the cursor in which the given \p cursor
 * was actually written. For many declarations, the lexical and semantic parents
 * are equivalent (the semantic parent is returned by
 * \c clang_getCursorSemanticParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 * void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For declarations written in the global scope, the lexical parent is
 * the translation unit.
 */
context(SegmentAllocator)
public fun clang_getCursorLexicalParent(cursor: CXCursor): CXCursor =
    CXCursor(`clang_getCursorLexicalParent$mh`.invokeExact(this@SegmentAllocator, cursor.`$mem`) as MemorySegment)

/**
 *
 * Determine the set of methods that are overridden by the given
 * method.
 *
 * In both Objective-C and C++, a method (aka virtual member function,
 * in C++) can override a virtual method in a base class. For
 * Objective-C, a method is said to override any method in the class's
 * base class, its protocols, or its categories' protocols, that has the same
 * selector and is of the same kind (class or instance).
 * If no such method exists, the search continues to the class's superclass,
 * its protocols, and its categories, and so on. A method from an Objective-C
 * implementation is considered to override the same methods as its
 * corresponding method in the interface.
 *
 * For C++, a virtual member function overrides any virtual member
 * function with the same signature that occurs in its base
 * classes. With multiple inheritance, a virtual member function can
 * override several virtual member functions coming from different
 * base classes.
 *
 * In all cases, this function determines the immediate overridden
 * method, rather than all of the overridden methods. For example, if
 * a method is originally declared in a class A, then overridden in B
 * (which in inherits from A) and also in C (which inherited from B),
 * then the only overridden method returned from this function when
 * invoked on C's method will be B's method. The client may then
 * invoke this function again, given the previously-found overridden
 * methods, to map out the complete method-override set.
 *
 * \param cursor A cursor representing an Objective-C or C++
 * method. This routine will compute the set of methods that this
 * method overrides.
 *
 * \param overridden A pointer whose pointee will be replaced with a
 * pointer to an array of cursors, representing the set of overridden
 * methods. If there are no overridden methods, the pointee will be
 * set to NULL. The pointee must be freed via a call to
 * \c clang_disposeOverriddenCursors().
 *
 * \param num_overridden A pointer to the number of overridden
 * functions, will be set to the number of overridden functions in the
 * array pointed to by \p overridden.
 */
public fun clang_getOverriddenCursors(
    cursor: CXCursor,
    overridden: Pointer<Pointer<CXCursor>>,
    num_overridden: Pointer<UInt>,
): Unit = `clang_getOverriddenCursors$mh`.invokeExact(cursor.`$mem`, overridden, num_overridden) as Unit

/**
 *
 * Free the set of overridden cursors returned by \c
 * clang_getOverriddenCursors().
 */
public fun clang_disposeOverriddenCursors(overridden: Pointer<CXCursor>): Unit =
    `clang_disposeOverriddenCursors$mh`.invokeExact(overridden) as Unit

/**
 *
 * Retrieve the file that is included by the given inclusion directive
 * cursor.
 */
public fun clang_getIncludedFile(cursor: CXCursor): CXFile =
    `clang_getIncludedFile$mh`.invokeExact(cursor.`$mem`) as MemorySegment

/**
 *
 * Map a source location to the cursor that describes the entity at that
 * location in the source code.
 *
 * clang_getCursor() maps an arbitrary source location within a translation
 * unit down to the most specific cursor that describes the entity at that
 * location. For example, given an expression \c x + y, invoking
 * clang_getCursor() with a source location pointing to "x" will return the
 * cursor for "x"; similarly for "y". If the cursor points anywhere between
 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
 * will return a cursor referring to the "+" expression.
 *
 * \returns a cursor representing the entity at the given source location, or
 * a NULL cursor if no such entity can be found.
 */
context(SegmentAllocator)
public fun clang_getCursor(`$p0`: CXTranslationUnit, `$p1`: CXSourceLocation): CXCursor =
    CXCursor(`clang_getCursor$mh`.invokeExact(this@SegmentAllocator, `$p0`, `$p1`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the physical location of the source constructor referenced
 * by the given cursor.
 *
 * The location of a declaration is typically the location of the name of that
 * declaration, where the name of that declaration would occur if it is
 * unnamed, or some keyword that introduces that particular declaration.
 * The location of a reference is where that reference occurs within the
 * source code.
 */
context(SegmentAllocator)
public fun clang_getCursorLocation(`$p0`: CXCursor): CXSourceLocation =
    CXSourceLocation(`clang_getCursorLocation$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the physical extent of the source construct referenced by
 * the given cursor.
 *
 * The extent of a cursor starts with the file/line/column pointing at the
 * first character within the source construct that the cursor refers to and
 * ends with the last character within that source construct. For a
 * declaration, the extent covers the declaration itself. For a reference,
 * the extent covers the location of the reference (e.g., where the referenced
 * entity was actually used).
 */
context(SegmentAllocator)
public fun clang_getCursorExtent(`$p0`: CXCursor): CXSourceRange =
    CXSourceRange(`clang_getCursorExtent$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the type of a CXCursor (if any).
 */
context(SegmentAllocator)
public fun clang_getCursorType(C: CXCursor): CXType =
    CXType(`clang_getCursorType$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Pretty-print the underlying type using the rules of the
 * language of the translation unit from which it came.
 *
 * If the type is invalid, an empty string is returned.
 */
context(SegmentAllocator)
public fun clang_getTypeSpelling(CT: CXType): CXString =
    CXString(`clang_getTypeSpelling$mh`.invokeExact(this@SegmentAllocator, CT.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the underlying type of a typedef declaration.
 *
 * If the cursor does not reference a typedef declaration, an invalid type is
 * returned.
 */
context(SegmentAllocator)
public fun clang_getTypedefDeclUnderlyingType(C: CXCursor): CXType =
    CXType(`clang_getTypedefDeclUnderlyingType$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the integer type of an enum declaration.
 *
 * If the cursor does not reference an enum declaration, an invalid type is
 * returned.
 */
context(SegmentAllocator)
public fun clang_getEnumDeclIntegerType(C: CXCursor): CXType =
    CXType(`clang_getEnumDeclIntegerType$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the integer value of an enum constant declaration as a signed
 * long long.
 *
 * If the cursor does not reference an enum constant declaration, LLONG_MIN is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */
public fun clang_getEnumConstantDeclValue(C: CXCursor): Long =
    `clang_getEnumConstantDeclValue$mh`.invokeExact(C.`$mem`) as Long

/**
 *
 * Retrieve the integer value of an enum constant declaration as an unsigned
 * long long.
 *
 * If the cursor does not reference an enum constant declaration, ULLONG_MAX is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */
public fun clang_getEnumConstantDeclUnsignedValue(C: CXCursor): ULong =
    (`clang_getEnumConstantDeclUnsignedValue$mh`.invokeExact(C.`$mem`) as Long).toULong()

/**
 *
 * Returns non-zero if the cursor specifies a Record member that is a bit-field.
 */
public fun clang_Cursor_isBitField(C: CXCursor): UInt =
    (`clang_Cursor_isBitField$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the bit width of a bit-field declaration as an integer.
 *
 * If the cursor does not reference a bit-field, or if the bit-field's width
 * expression cannot be evaluated, -1 is returned.
 *
 * For example:
 * \code
 * if (clang_Cursor_isBitField(Cursor)) {
 * int Width = clang_getFieldDeclBitWidth(Cursor);
 * if (Width != -1) {
 * // The bit-field width is not value-dependent.
 * }
 * }
 * \endcode
 */
public fun clang_getFieldDeclBitWidth(C: CXCursor): Int = `clang_getFieldDeclBitWidth$mh`.invokeExact(C.`$mem`) as Int

/**
 *
 * Retrieve the number of non-variadic arguments associated with a given
 * cursor.
 *
 * The number of arguments can be determined for calls as well as for
 * declarations of functions or methods. For other cursors -1 is returned.
 */
public fun clang_Cursor_getNumArguments(C: CXCursor): Int =
    `clang_Cursor_getNumArguments$mh`.invokeExact(C.`$mem`) as Int

/**
 *
 * Retrieve the argument cursor of a function or method.
 *
 * The argument cursor can be determined for calls as well as for declarations
 * of functions or methods. For other cursors and for invalid indices, an
 * invalid cursor is returned.
 */
context(SegmentAllocator)
public fun clang_Cursor_getArgument(C: CXCursor, i: UInt): CXCursor =
    CXCursor(`clang_Cursor_getArgument$mh`.invokeExact(this@SegmentAllocator, C.`$mem`, i.toInt()) as MemorySegment)

/**
 *
 * Returns the number of template args of a function, struct, or class decl
 * representing a template specialization.
 *
 * If the argument cursor cannot be converted into a template function
 * declaration, -1 is returned.
 *
 * For example, for the following declaration and specialization:
 * template <typename T, int kInt, bool kBool>
 * void foo() { ... }
 *
 * template <>
 * void foo<float, -7, true>();
 *
 * The value 3 would be returned from this call.
 */
public fun clang_Cursor_getNumTemplateArguments(C: CXCursor): Int =
    `clang_Cursor_getNumTemplateArguments$mh`.invokeExact(C.`$mem`) as Int

/**
 *
 * Retrieve the kind of the I'th template argument of the CXCursor C.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl, or
 * ClassTemplatePartialSpecialization, an invalid template argument kind is
 * returned.
 *
 * For example, for the following declaration and specialization:
 * template <typename T, int kInt, bool kBool>
 * void foo() { ... }
 *
 * template <>
 * void foo<float, -7, true>();
 *
 * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
 * respectively.
 */
public fun clang_Cursor_getTemplateArgumentKind(C: CXCursor, I: UInt): CXTemplateArgumentKind =
    CXTemplateArgumentKind.fromInt(`clang_Cursor_getTemplateArgumentKind$mh`.invokeExact(C.`$mem`, I.toInt()) as Int)

/**
 *
 * Retrieve a CXType representing the type of a TemplateArgument of a
 * function decl representing a template specialization.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl,
 * ClassDecl or ClassTemplatePartialSpecialization whose I'th template argument
 * has a kind of CXTemplateArgKind_Integral, an invalid type is returned.
 *
 * For example, for the following declaration and specialization:
 * template <typename T, int kInt, bool kBool>
 * void foo() { ... }
 *
 * template <>
 * void foo<float, -7, true>();
 *
 * If called with I = 0, "float", will be returned.
 * Invalid types will be returned for I == 1 or 2.
 */
context(SegmentAllocator)
public fun clang_Cursor_getTemplateArgumentType(C: CXCursor, I: UInt): CXType = CXType(
    `clang_Cursor_getTemplateArgumentType$mh`.invokeExact(
        this@SegmentAllocator,
        C.`$mem`,
        I.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the value of an Integral TemplateArgument (of a function
 * decl representing a template specialization) as a signed long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 * template <typename T, int kInt, bool kBool>
 * void foo() { ... }
 *
 * template <>
 * void foo<float, -7, true>();
 *
 * If called with I = 1 or 2, -7 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
public fun clang_Cursor_getTemplateArgumentValue(C: CXCursor, I: UInt): Long =
    `clang_Cursor_getTemplateArgumentValue$mh`.invokeExact(C.`$mem`, I.toInt()) as Long

/**
 *
 * Retrieve the value of an Integral TemplateArgument (of a function
 * decl representing a template specialization) as an unsigned long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization or
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 * template <typename T, int kInt, bool kBool>
 * void foo() { ... }
 *
 * template <>
 * void foo<float, 2147483649, true>();
 *
 * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
public fun clang_Cursor_getTemplateArgumentUnsignedValue(C: CXCursor, I: UInt): ULong =
    (`clang_Cursor_getTemplateArgumentUnsignedValue$mh`.invokeExact(C.`$mem`, I.toInt()) as Long).toULong()

/**
 *
 * Determine whether two CXTypes represent the same type.
 *
 * \returns non-zero if the CXTypes represent the same type and
 * zero otherwise.
 */
public fun clang_equalTypes(A: CXType, B: CXType): UInt =
    (`clang_equalTypes$mh`.invokeExact(A.`$mem`, B.`$mem`) as Int).toUInt()

/**
 *
 * Return the canonical type for a CXType.
 *
 * Clang's type system explicitly models typedefs and all the ways
 * a specific type can be represented.  The canonical type is the underlying
 * type with all the "sugar" removed.  For example, if 'T' is a typedef
 * for 'int', the canonical type for 'T' would be 'int'.
 */
context(SegmentAllocator)
public fun clang_getCanonicalType(T: CXType): CXType =
    CXType(`clang_getCanonicalType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Determine whether a CXType has the "const" qualifier set,
 * without looking through typedefs that may have added "const" at a
 * different level.
 */
public fun clang_isConstQualifiedType(T: CXType): UInt =
    (`clang_isConstQualifiedType$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether a  CXCursor that is a macro, is
 * function like.
 */
public fun clang_Cursor_isMacroFunctionLike(C: CXCursor): UInt =
    (`clang_Cursor_isMacroFunctionLike$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether a  CXCursor that is a macro, is a
 * builtin one.
 */
public fun clang_Cursor_isMacroBuiltin(C: CXCursor): UInt =
    (`clang_Cursor_isMacroBuiltin$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether a  CXCursor that is a function declaration, is an
 * inline declaration.
 */
public fun clang_Cursor_isFunctionInlined(C: CXCursor): UInt =
    (`clang_Cursor_isFunctionInlined$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether a CXType has the "volatile" qualifier set,
 * without looking through typedefs that may have added "volatile" at
 * a different level.
 */
public fun clang_isVolatileQualifiedType(T: CXType): UInt =
    (`clang_isVolatileQualifiedType$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether a CXType has the "restrict" qualifier set,
 * without looking through typedefs that may have added "restrict" at a
 * different level.
 */
public fun clang_isRestrictQualifiedType(T: CXType): UInt =
    (`clang_isRestrictQualifiedType$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Returns the address space of the given type.
 */
public fun clang_getAddressSpace(T: CXType): UInt = (`clang_getAddressSpace$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Returns the typedef name of the given type.
 */
context(SegmentAllocator)
public fun clang_getTypedefName(CT: CXType): CXString =
    CXString(`clang_getTypedefName$mh`.invokeExact(this@SegmentAllocator, CT.`$mem`) as MemorySegment)

/**
 *
 * For pointer types, returns the type of the pointee.
 */
context(SegmentAllocator)
public fun clang_getPointeeType(T: CXType): CXType =
    CXType(`clang_getPointeeType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the unqualified variant of the given type, removing as
 * little sugar as possible.
 *
 * For example, given the following series of typedefs:
 *
 * \code
 * typedef int Integer;
 * typedef const Integer CInteger;
 * typedef CInteger DifferenceType;
 * \endcode
 *
 * Executing \c clang_getUnqualifiedType() on a \c CXType that
 * represents \c DifferenceType, will desugar to a type representing
 * \c Integer, that has no qualifiers.
 *
 * And, executing \c clang_getUnqualifiedType() on the type of the
 * first argument of the following function declaration:
 *
 * \code
 * void foo(const int);
 * \endcode
 *
 * Will return a type representing \c int, removing the \c const
 * qualifier.
 *
 * Sugar over array types is not desugared.
 *
 * A type can be checked for qualifiers with \c
 * clang_isConstQualifiedType(), \c clang_isVolatileQualifiedType()
 * and \c clang_isRestrictQualifiedType().
 *
 * A type that resulted from a call to \c clang_getUnqualifiedType
 * will return \c false for all of the above calls.
 */
context(SegmentAllocator)
public fun clang_getUnqualifiedType(CT: CXType): CXType =
    CXType(`clang_getUnqualifiedType$mh`.invokeExact(this@SegmentAllocator, CT.`$mem`) as MemorySegment)

/**
 *
 * For reference types (e.g., "const int&"), returns the type that the
 * reference refers to (e.g "const int").
 *
 * Otherwise, returns the type itself.
 *
 * A type that has kind \c CXType_LValueReference or
 * \c CXType_RValueReference is a reference type.
 */
context(SegmentAllocator)
public fun clang_getNonReferenceType(CT: CXType): CXType =
    CXType(`clang_getNonReferenceType$mh`.invokeExact(this@SegmentAllocator, CT.`$mem`) as MemorySegment)

/**
 *
 * Return the cursor for the declaration of the given type.
 */
context(SegmentAllocator)
public fun clang_getTypeDeclaration(T: CXType): CXCursor =
    CXCursor(`clang_getTypeDeclaration$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Returns the Objective-C type encoding for the specified declaration.
 */
context(SegmentAllocator)
public fun clang_getDeclObjCTypeEncoding(C: CXCursor): CXString =
    CXString(`clang_getDeclObjCTypeEncoding$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Returns the Objective-C type encoding for the specified CXType.
 */
context(SegmentAllocator)
public fun clang_Type_getObjCEncoding(type: CXType): CXString =
    CXString(`clang_Type_getObjCEncoding$mh`.invokeExact(this@SegmentAllocator, type.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the spelling of a given CXTypeKind.
 */
context(SegmentAllocator)
public fun clang_getTypeKindSpelling(K: CXTypeKind): CXString =
    CXString(`clang_getTypeKindSpelling$mh`.invokeExact(this@SegmentAllocator, K.value) as MemorySegment)

/**
 *
 * Retrieve the calling convention associated with a function type.
 *
 * If a non-function type is passed in, CXCallingConv_Invalid is returned.
 */
public fun clang_getFunctionTypeCallingConv(T: CXType): CXCallingConv =
    CXCallingConv.fromInt(`clang_getFunctionTypeCallingConv$mh`.invokeExact(T.`$mem`) as Int)

/**
 *
 * Retrieve the return type associated with a function type.
 *
 * If a non-function type is passed in, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_getResultType(T: CXType): CXType =
    CXType(`clang_getResultType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the exception specification type associated with a function type.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * If a non-function type is passed in, an error code of -1 is returned.
 */
public fun clang_getExceptionSpecificationType(T: CXType): Int =
    `clang_getExceptionSpecificationType$mh`.invokeExact(T.`$mem`) as Int

/**
 *
 * Retrieve the number of non-variadic parameters associated with a
 * function type.
 *
 * If a non-function type is passed in, -1 is returned.
 */
public fun clang_getNumArgTypes(T: CXType): Int = `clang_getNumArgTypes$mh`.invokeExact(T.`$mem`) as Int

/**
 *
 * Retrieve the type of a parameter of a function type.
 *
 * If a non-function type is passed in or the function does not have enough
 * parameters, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_getArgType(T: CXType, i: UInt): CXType =
    CXType(`clang_getArgType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`, i.toInt()) as MemorySegment)

/**
 *
 * Retrieves the base type of the ObjCObjectType.
 *
 * If the type is not an ObjC object, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getObjCObjectBaseType(T: CXType): CXType =
    CXType(`clang_Type_getObjCObjectBaseType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the number of protocol references associated with an ObjC object/id.
 *
 * If the type is not an ObjC object, 0 is returned.
 */
public fun clang_Type_getNumObjCProtocolRefs(T: CXType): UInt =
    (`clang_Type_getNumObjCProtocolRefs$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the decl for a protocol reference for an ObjC object/id.
 *
 * If the type is not an ObjC object or there are not enough protocol
 * references, an invalid cursor is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getObjCProtocolDecl(T: CXType, i: UInt): CXCursor = CXCursor(
    `clang_Type_getObjCProtocolDecl$mh`.invokeExact(
        this@SegmentAllocator,
        T.`$mem`,
        i.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the number of type arguments associated with an ObjC object.
 *
 * If the type is not an ObjC object, 0 is returned.
 */
public fun clang_Type_getNumObjCTypeArgs(T: CXType): UInt =
    (`clang_Type_getNumObjCTypeArgs$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve a type argument associated with an ObjC object.
 *
 * If the type is not an ObjC or the index is not valid,
 * an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getObjCTypeArg(T: CXType, i: UInt): CXType =
    CXType(`clang_Type_getObjCTypeArg$mh`.invokeExact(this@SegmentAllocator, T.`$mem`, i.toInt()) as MemorySegment)

/**
 *
 * Return 1 if the CXType is a variadic function type, and 0 otherwise.
 */
public fun clang_isFunctionTypeVariadic(T: CXType): UInt =
    (`clang_isFunctionTypeVariadic$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the return type associated with a given cursor.
 *
 * This only returns a valid type if the cursor refers to a function or method.
 */
context(SegmentAllocator)
public fun clang_getCursorResultType(C: CXCursor): CXType =
    CXType(`clang_getCursorResultType$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the exception specification type associated with a given cursor.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * This only returns a valid result if the cursor refers to a function or
 * method.
 */
public fun clang_getCursorExceptionSpecificationType(C: CXCursor): Int =
    `clang_getCursorExceptionSpecificationType$mh`.invokeExact(C.`$mem`) as Int

/**
 *
 * Return 1 if the CXType is a POD (plain old data) type, and 0
 * otherwise.
 */
public fun clang_isPODType(T: CXType): UInt = (`clang_isPODType$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Return the element type of an array, complex, or vector type.
 *
 * If a type is passed in that is not an array, complex, or vector type,
 * an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_getElementType(T: CXType): CXType =
    CXType(`clang_getElementType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Return the number of elements of an array or vector type.
 *
 * If a type is passed in that is not an array or vector type,
 * -1 is returned.
 */
public fun clang_getNumElements(T: CXType): Long = `clang_getNumElements$mh`.invokeExact(T.`$mem`) as Long

/**
 *
 * Return the element type of an array type.
 *
 * If a non-array type is passed in, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_getArrayElementType(T: CXType): CXType =
    CXType(`clang_getArrayElementType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Return the array size of a constant array.
 *
 * If a non-array type is passed in, -1 is returned.
 */
public fun clang_getArraySize(T: CXType): Long = `clang_getArraySize$mh`.invokeExact(T.`$mem`) as Long

/**
 *
 * Retrieve the type named by the qualified-id.
 *
 * If a non-elaborated type is passed in, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getNamedType(T: CXType): CXType =
    CXType(`clang_Type_getNamedType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Determine if a typedef is 'transparent' tag.
 *
 * A typedef is considered 'transparent' if it shares a name and spelling
 * location with its underlying tag type, as is the case with the NS_ENUM macro.
 *
 * \returns non-zero if transparent and zero otherwise.
 */
public fun clang_Type_isTransparentTagTypedef(T: CXType): UInt =
    (`clang_Type_isTransparentTagTypedef$mh`.invokeExact(T.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the nullability kind of a pointer type.
 */
public fun clang_Type_getNullability(T: CXType): CXTypeNullabilityKind =
    CXTypeNullabilityKind.fromInt(`clang_Type_getNullability$mh`.invokeExact(T.`$mem`) as Int)

/**
 *
 * Return the alignment of a type in bytes as per C++[expr.alignof]
 * standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 * is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 * returned.
 * If the type declaration is not a constant size type,
 * CXTypeLayoutError_NotConstantSize is returned.
 */
public fun clang_Type_getAlignOf(T: CXType): Long = `clang_Type_getAlignOf$mh`.invokeExact(T.`$mem`) as Long

/**
 *
 * Return the class type of an member pointer type.
 *
 * If a non-member-pointer type is passed in, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getClassType(T: CXType): CXType =
    CXType(`clang_Type_getClassType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Return the size of a type in bytes as per C++[expr.sizeof] standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 * is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 * returned.
 */
public fun clang_Type_getSizeOf(T: CXType): Long = `clang_Type_getSizeOf$mh`.invokeExact(T.`$mem`) as Long

/**
 *
 * Return the offset of a field named S in a record of type T in bits
 * as it would be returned by __offsetof__ as per C++11[18.2p4]
 *
 * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
 * is returned.
 * If the field's type declaration is an incomplete type,
 * CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 * CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 * CXTypeLayoutError_InvalidFieldName is returned.
 */
public fun clang_Type_getOffsetOf(T: CXType, S: Pointer<Byte>): Long =
    `clang_Type_getOffsetOf$mh`.invokeExact(T.`$mem`, S) as Long

/**
 *
 * Return the type that was modified by this attributed type.
 *
 * If the type is not an attributed type, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getModifiedType(T: CXType): CXType =
    CXType(`clang_Type_getModifiedType$mh`.invokeExact(this@SegmentAllocator, T.`$mem`) as MemorySegment)

/**
 *
 * Gets the type contained by this atomic type.
 *
 * If a non-atomic type is passed in, an invalid type is returned.
 */
context(SegmentAllocator)
public fun clang_Type_getValueType(CT: CXType): CXType =
    CXType(`clang_Type_getValueType$mh`.invokeExact(this@SegmentAllocator, CT.`$mem`) as MemorySegment)

/**
 *
 * Return the offset of the field represented by the Cursor.
 *
 * If the cursor is not a field declaration, -1 is returned.
 * If the cursor semantic parent is not a record field declaration,
 * CXTypeLayoutError_Invalid is returned.
 * If the field's type declaration is an incomplete type,
 * CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 * CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 * CXTypeLayoutError_InvalidFieldName is returned.
 */
public fun clang_Cursor_getOffsetOfField(C: CXCursor): Long =
    `clang_Cursor_getOffsetOfField$mh`.invokeExact(C.`$mem`) as Long

/**
 *
 * Determine whether the given cursor represents an anonymous
 * tag or namespace
 */
public fun clang_Cursor_isAnonymous(C: CXCursor): UInt =
    (`clang_Cursor_isAnonymous$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether the given cursor represents an anonymous record
 * declaration.
 */
public fun clang_Cursor_isAnonymousRecordDecl(C: CXCursor): UInt =
    (`clang_Cursor_isAnonymousRecordDecl$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine whether the given cursor represents an inline namespace
 * declaration.
 */
public fun clang_Cursor_isInlineNamespace(C: CXCursor): UInt =
    (`clang_Cursor_isInlineNamespace$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Returns the number of template arguments for given template
 * specialization, or -1 if type \c T is not a template specialization.
 */
public fun clang_Type_getNumTemplateArguments(T: CXType): Int =
    `clang_Type_getNumTemplateArguments$mh`.invokeExact(T.`$mem`) as Int

/**
 *
 * Returns the type template argument of a template class specialization
 * at given index.
 *
 * This function only returns template type arguments and does not handle
 * template template arguments or variadic packs.
 */
context(SegmentAllocator)
public fun clang_Type_getTemplateArgumentAsType(T: CXType, i: UInt): CXType = CXType(
    `clang_Type_getTemplateArgumentAsType$mh`.invokeExact(
        this@SegmentAllocator,
        T.`$mem`,
        i.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the ref-qualifier kind of a function or method.
 *
 * The ref-qualifier is returned for C++ functions or methods. For other types
 * or non-C++ declarations, CXRefQualifier_None is returned.
 */
public fun clang_Type_getCXXRefQualifier(T: CXType): CXRefQualifierKind =
    CXRefQualifierKind.fromInt(`clang_Type_getCXXRefQualifier$mh`.invokeExact(T.`$mem`) as Int)

/**
 *
 * Returns 1 if the base class specified by the cursor with kind
 * CX_CXXBaseSpecifier is virtual.
 */
public fun clang_isVirtualBase(`$p0`: CXCursor): UInt =
    (`clang_isVirtualBase$mh`.invokeExact(`$p0`.`$mem`) as Int).toUInt()

/**
 *
 * Returns the access control level for the referenced object.
 *
 * If the cursor refers to a C++ declaration, its access control level within
 * its parent scope is returned. Otherwise, if the cursor refers to a base
 * specifier or access specifier, the specifier itself is returned.
 */
public fun clang_getCXXAccessSpecifier(`$p0`: CXCursor): CX_CXXAccessSpecifier =
    CX_CXXAccessSpecifier.fromInt(`clang_getCXXAccessSpecifier$mh`.invokeExact(`$p0`.`$mem`) as Int)

/**
 *
 * \brief Returns the operator code for the binary operator.
 */
public fun clang_Cursor_getBinaryOpcode(C: CXCursor): CX_BinaryOperatorKind =
    CX_BinaryOperatorKind.fromInt(`clang_Cursor_getBinaryOpcode$mh`.invokeExact(C.`$mem`) as Int)

/**
 *
 * \brief Returns a string containing the spelling of the binary operator.
 */
context(SegmentAllocator)
public fun clang_Cursor_getBinaryOpcodeStr(Op: CX_BinaryOperatorKind): CXString =
    CXString(`clang_Cursor_getBinaryOpcodeStr$mh`.invokeExact(this@SegmentAllocator, Op.value) as MemorySegment)

/**
 *
 * Returns the storage class for a function or variable declaration.
 *
 * If the passed in Cursor is not a function or variable declaration,
 * CX_SC_Invalid is returned else the storage class.
 */
public fun clang_Cursor_getStorageClass(`$p0`: CXCursor): CX_StorageClass =
    CX_StorageClass.fromInt(`clang_Cursor_getStorageClass$mh`.invokeExact(`$p0`.`$mem`) as Int)

/**
 *
 * Determine the number of overloaded declarations referenced by a
 * \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \returns The number of overloaded declarations referenced by \c cursor. If it
 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.
 */
public fun clang_getNumOverloadedDecls(cursor: CXCursor): UInt =
    (`clang_getNumOverloadedDecls$mh`.invokeExact(cursor.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve a cursor for one of the overloaded declarations referenced
 * by a \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \param index The zero-based index into the set of overloaded declarations in
 * the cursor.
 *
 * \returns A cursor representing the declaration referenced by the given
 * \c cursor at the specified \c index. If the cursor does not have an
 * associated set of overloaded declarations, or if the index is out of bounds,
 * returns \c clang_getNullCursor();
 */
context(SegmentAllocator)
public fun clang_getOverloadedDecl(cursor: CXCursor, index: UInt): CXCursor = CXCursor(
    `clang_getOverloadedDecl$mh`.invokeExact(
        this@SegmentAllocator,
        cursor.`$mem`,
        index.toInt(),
    ) as MemorySegment
)

/**
 *
 * For cursors representing an iboutletcollection attribute,
 * this function returns the collection element type.
 */
context(SegmentAllocator)
public fun clang_getIBOutletCollectionType(`$p0`: CXCursor): CXType =
    CXType(`clang_getIBOutletCollectionType$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Visit the children of a particular cursor.
 *
 * This function visits all the direct children of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited child. The traversal may be recursive, if the visitor returns
 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if
 * the visitor returns \c CXChildVisit_Break.
 *
 * \param parent the cursor whose child may be visited. All kinds of
 * cursors can be visited, including invalid cursors (which, by
 * definition, have no children).
 *
 * \param visitor the visitor function that will be invoked for each
 * child of \p parent.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXChildVisit_Break.
 */
public fun clang_visitChildren(
    parent: CXCursor,
    visitor: CXCursorVisitor,
    client_data: CXClientData,
): UInt = (`clang_visitChildren$mh`.invokeExact(parent.`$mem`, visitor, client_data) as Int).toUInt()

/**
 *
 * Visits the children of a cursor using the specified block.  Behaves
 * identically to clang_visitChildren() in all other respects.
 */
public fun clang_visitChildrenWithBlock(parent: CXCursor, block: CXCursorVisitorBlock): UInt =
    (`clang_visitChildrenWithBlock$mh`.invokeExact(parent.`$mem`, block) as Int).toUInt()

/**
 *
 * Retrieve a Unified Symbol Resolution (USR) for the entity referenced
 * by the given cursor.
 *
 * A Unified Symbol Resolution (USR) is a string that identifies a particular
 * entity (function, class, variable, etc.) within a program. USRs can be
 * compared across translation units to determine, e.g., when references in
 * one translation refer to an entity defined in another translation unit.
 */
context(SegmentAllocator)
public fun clang_getCursorUSR(`$p0`: CXCursor): CXString =
    CXString(`clang_getCursorUSR$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Construct a USR for a specified Objective-C class.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCClass(class_name: Pointer<Byte>): CXString =
    CXString(`clang_constructUSR_ObjCClass$mh`.invokeExact(this@SegmentAllocator, class_name) as MemorySegment)

/**
 *
 * Construct a USR for a specified Objective-C category.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCCategory(class_name: Pointer<Byte>, category_name: Pointer<Byte>): CXString =
    CXString(
        `clang_constructUSR_ObjCCategory$mh`.invokeExact(
            this@SegmentAllocator,
            class_name,
            category_name,
        ) as MemorySegment
    )

/**
 *
 * Construct a USR for a specified Objective-C protocol.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCProtocol(protocol_name: Pointer<Byte>): CXString =
    CXString(`clang_constructUSR_ObjCProtocol$mh`.invokeExact(this@SegmentAllocator, protocol_name) as MemorySegment)

/**
 *
 * Construct a USR for a specified Objective-C instance variable and
 * the USR for its containing class.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCIvar(name: Pointer<Byte>, classUSR: CXString): CXString = CXString(
    `clang_constructUSR_ObjCIvar$mh`.invokeExact(
        this@SegmentAllocator,
        name,
        classUSR.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Construct a USR for a specified Objective-C method and
 * the USR for its containing class.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCMethod(
    name: Pointer<Byte>,
    isInstanceMethod: UInt,
    classUSR: CXString,
): CXString = CXString(
    `clang_constructUSR_ObjCMethod$mh`.invokeExact(
        this@SegmentAllocator,
        name,
        isInstanceMethod.toInt(),
        classUSR.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Construct a USR for a specified Objective-C property and the USR
 * for its containing class.
 */
context(SegmentAllocator)
public fun clang_constructUSR_ObjCProperty(`property`: Pointer<Byte>, classUSR: CXString): CXString = CXString(
    `clang_constructUSR_ObjCProperty$mh`.invokeExact(
        this@SegmentAllocator,
        `property`,
        classUSR.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Retrieve a name for the entity referenced by this cursor.
 */
context(SegmentAllocator)
public fun clang_getCursorSpelling(`$p0`: CXCursor): CXString =
    CXString(`clang_getCursorSpelling$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve a range for a piece that forms the cursors spelling name.
 * Most of the times there is only one range for the complete spelling but for
 * Objective-C methods and Objective-C message expressions, there are multiple
 * pieces for each selector identifier.
 *
 * \param pieceIndex the index of the spelling name piece. If this is greater
 * than the actual number of pieces, it will return a NULL (invalid) range.
 *
 * \param options Reserved.
 */
context(SegmentAllocator)
public fun clang_Cursor_getSpellingNameRange(
    `$p0`: CXCursor,
    pieceIndex: UInt,
    options: UInt,
): CXSourceRange = CXSourceRange(
    `clang_Cursor_getSpellingNameRange$mh`.invokeExact(
        this@SegmentAllocator,
        `$p0`.`$mem`,
        pieceIndex.toInt(),
        options.toInt(),
    ) as MemorySegment
)

/**
 *
 * Get a property value for the given printing policy.
 */
public fun clang_PrintingPolicy_getProperty(Policy: CXPrintingPolicy, Property: CXPrintingPolicyProperty): UInt =
    (`clang_PrintingPolicy_getProperty$mh`.invokeExact(Policy, Property.value) as Int).toUInt()

/**
 *
 * Set a property value for the given printing policy.
 */
public fun clang_PrintingPolicy_setProperty(
    Policy: CXPrintingPolicy,
    Property: CXPrintingPolicyProperty,
    Value: UInt,
): Unit = `clang_PrintingPolicy_setProperty$mh`.invokeExact(Policy, Property.value, Value.toInt()) as Unit

/**
 *
 * Retrieve the default policy for the cursor.
 *
 * The policy should be released after use with \c
 * clang_PrintingPolicy_dispose.
 */
public fun clang_getCursorPrintingPolicy(`$p0`: CXCursor): CXPrintingPolicy =
    `clang_getCursorPrintingPolicy$mh`.invokeExact(`$p0`.`$mem`) as MemorySegment

/**
 *
 * Release a printing policy.
 */
public fun clang_PrintingPolicy_dispose(Policy: CXPrintingPolicy): Unit =
    `clang_PrintingPolicy_dispose$mh`.invokeExact(Policy) as Unit

/**
 *
 * Pretty print declarations.
 *
 * \param Cursor The cursor representing a declaration.
 *
 * \param Policy The policy to control the entities being printed. If
 * NULL, a default policy is used.
 *
 * \returns The pretty printed declaration or the empty string for
 * other cursors.
 */
context(SegmentAllocator)
public fun clang_getCursorPrettyPrinted(Cursor: CXCursor, Policy: CXPrintingPolicy): CXString = CXString(
    `clang_getCursorPrettyPrinted$mh`.invokeExact(
        this@SegmentAllocator,
        Cursor.`$mem`,
        Policy,
    ) as MemorySegment
)

/**
 *
 * Retrieve the display name for the entity referenced by this cursor.
 *
 * The display name contains extra information that helps identify the cursor,
 * such as the parameters of a function or template or the arguments of a
 * class template specialization.
 */
context(SegmentAllocator)
public fun clang_getCursorDisplayName(`$p0`: CXCursor): CXString =
    CXString(`clang_getCursorDisplayName$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 * For a cursor that is a reference, retrieve a cursor representing the
 * entity that it references.
 *
 * Reference cursors refer to other entities in the AST. For example, an
 * Objective-C superclass reference cursor refers to an Objective-C class.
 * This function produces the cursor for the Objective-C class from the
 * cursor for the superclass reference. If the input cursor is a declaration or
 * definition, it returns that declaration or definition unchanged.
 * Otherwise, returns the NULL cursor.
 */
context(SegmentAllocator)
public fun clang_getCursorReferenced(`$p0`: CXCursor): CXCursor =
    CXCursor(`clang_getCursorReferenced$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * For a cursor that is either a reference to or a declaration
 * of some entity, retrieve a cursor that describes the definition of
 * that entity.
 *
 * Some entities can be declared multiple times within a translation
 * unit, but only one of those declarations can also be a
 * definition. For example, given:
 *
 * \code
 * int f(int, int);
 * int g(int x, int y) { return f(x, y); }
 * int f(int a, int b) { return a + b; }
 * int f(int, int);
 * \endcode
 *
 * there are three declarations of the function "f", but only the
 * second one is a definition. The clang_getCursorDefinition()
 * function will take any cursor pointing to a declaration of "f"
 * (the first or fourth lines of the example) or a cursor referenced
 * that uses "f" (the call to "f' inside "g") and will return a
 * declaration cursor pointing to the definition (the second "f"
 * declaration).
 *
 * If given a cursor for which there is no corresponding definition,
 * e.g., because there is no definition of that entity within this
 * translation unit, returns a NULL cursor.
 */
context(SegmentAllocator)
public fun clang_getCursorDefinition(`$p0`: CXCursor): CXCursor =
    CXCursor(`clang_getCursorDefinition$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Determine whether the declaration pointed to by this cursor
 * is also a definition of that entity.
 */
public fun clang_isCursorDefinition(`$p0`: CXCursor): UInt =
    (`clang_isCursorDefinition$mh`.invokeExact(`$p0`.`$mem`) as Int).toUInt()

/**
 *
 * Retrieve the canonical cursor corresponding to the given cursor.
 *
 * In the C family of languages, many kinds of entities can be declared several
 * times within a single translation unit. For example, a structure type can
 * be forward-declared (possibly multiple times) and later defined:
 *
 * \code
 * struct X;
 * struct X;
 * struct X {
 * int member;
 * };
 * \endcode
 *
 * The declarations and the definition of \c X are represented by three
 * different cursors, all of which are declarations of the same underlying
 * entity. One of these cursor is considered the "canonical" cursor, which
 * is effectively the representative for the underlying entity. One can
 * determine if two cursors are declarations of the same underlying entity by
 * comparing their canonical cursors.
 *
 * \returns The canonical cursor for the entity referred to by the given cursor.
 */
context(SegmentAllocator)
public fun clang_getCanonicalCursor(`$p0`: CXCursor): CXCursor =
    CXCursor(`clang_getCanonicalCursor$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * If the cursor points to a selector identifier in an Objective-C
 * method or message expression, this returns the selector index.
 *
 * After getting a cursor with #clang_getCursor, this can be called to
 * determine if the location points to a selector identifier.
 *
 * \returns The selector index if the cursor is an Objective-C method or message
 * expression and the cursor is pointing to a selector identifier, or -1
 * otherwise.
 */
public fun clang_Cursor_getObjCSelectorIndex(`$p0`: CXCursor): Int =
    `clang_Cursor_getObjCSelectorIndex$mh`.invokeExact(`$p0`.`$mem`) as Int

/**
 *
 * Given a cursor pointing to a C++ method call or an Objective-C
 * message, returns non-zero if the method/message is "dynamic", meaning:
 *
 * For a C++ method: the call is virtual.
 * For an Objective-C message: the receiver is an object instance, not 'super'
 * or a specific class.
 *
 * If the method/message is "static" or the cursor does not point to a
 * method/message, it will return zero.
 */
public fun clang_Cursor_isDynamicCall(C: CXCursor): Int = `clang_Cursor_isDynamicCall$mh`.invokeExact(C.`$mem`) as Int

/**
 *
 * Given a cursor pointing to an Objective-C message or property
 * reference, or C++ method call, returns the CXType of the receiver.
 */
context(SegmentAllocator)
public fun clang_Cursor_getReceiverType(C: CXCursor): CXType =
    CXType(`clang_Cursor_getReceiverType$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that represents a property declaration, return the
 * associated property attributes. The bits are formed from
 * \c CXObjCPropertyAttrKind.
 *
 * \param reserved Reserved for future use, pass 0.
 */
public fun clang_Cursor_getObjCPropertyAttributes(C: CXCursor, reserved: UInt): UInt =
    (`clang_Cursor_getObjCPropertyAttributes$mh`.invokeExact(C.`$mem`, reserved.toInt()) as Int).toUInt()

/**
 *
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the getter.
 */
context(SegmentAllocator)
public fun clang_Cursor_getObjCPropertyGetterName(C: CXCursor): CXString =
    CXString(`clang_Cursor_getObjCPropertyGetterName$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the setter, if any.
 */
context(SegmentAllocator)
public fun clang_Cursor_getObjCPropertySetterName(C: CXCursor): CXString =
    CXString(`clang_Cursor_getObjCPropertySetterName$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that represents an Objective-C method or parameter
 * declaration, return the associated Objective-C qualifiers for the return
 * type or the parameter respectively. The bits are formed from
 * CXObjCDeclQualifierKind.
 */
public fun clang_Cursor_getObjCDeclQualifiers(C: CXCursor): UInt =
    (`clang_Cursor_getObjCDeclQualifiers$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Given a cursor that represents an Objective-C method or property
 * declaration, return non-zero if the declaration was affected by "\@optional".
 * Returns zero if the cursor is not such a declaration or it is "\@required".
 */
public fun clang_Cursor_isObjCOptional(C: CXCursor): UInt =
    (`clang_Cursor_isObjCOptional$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Returns non-zero if the given cursor is a variadic function or method.
 */
public fun clang_Cursor_isVariadic(C: CXCursor): UInt =
    (`clang_Cursor_isVariadic$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Returns non-zero if the given cursor points to a symbol marked with
 * external_source_symbol attribute.
 *
 * \param language If non-NULL, and the attribute is present, will be set to
 * the 'language' string from the attribute.
 *
 * \param definedIn If non-NULL, and the attribute is present, will be set to
 * the 'definedIn' string from the attribute.
 *
 * \param isGenerated If non-NULL, and the attribute is present, will be set to
 * non-zero if the 'generated_declaration' is set in the attribute.
 */
public fun clang_Cursor_isExternalSymbol(
    C: CXCursor,
    language: Pointer<CXString>,
    definedIn: Pointer<CXString>,
    isGenerated: Pointer<UInt>,
): UInt = (`clang_Cursor_isExternalSymbol$mh`.invokeExact(C.`$mem`, language, definedIn, isGenerated) as Int).toUInt()

/**
 *
 * Given a cursor that represents a declaration, return the associated
 * comment's source range.  The range may include multiple consecutive comments
 * with whitespace in between.
 */
context(SegmentAllocator)
public fun clang_Cursor_getCommentRange(C: CXCursor): CXSourceRange =
    CXSourceRange(`clang_Cursor_getCommentRange$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that represents a declaration, return the associated
 * comment text, including comment markers.
 */
context(SegmentAllocator)
public fun clang_Cursor_getRawCommentText(C: CXCursor): CXString =
    CXString(`clang_Cursor_getRawCommentText$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated \paragraph; otherwise return the
 * first paragraph.
 */
context(SegmentAllocator)
public fun clang_Cursor_getBriefCommentText(C: CXCursor): CXString =
    CXString(`clang_Cursor_getBriefCommentText$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the CXString representing the mangled name of the cursor.
 */
context(SegmentAllocator)
public fun clang_Cursor_getMangling(`$p0`: CXCursor): CXString =
    CXString(`clang_Cursor_getMangling$mh`.invokeExact(this@SegmentAllocator, `$p0`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the CXStrings representing the mangled symbols of the C++
 * constructor or destructor at the cursor.
 */
public fun clang_Cursor_getCXXManglings(`$p0`: CXCursor): Pointer<CXStringSet> =
    `clang_Cursor_getCXXManglings$mh`.invokeExact(`$p0`.`$mem`) as MemorySegment

/**
 *
 * Retrieve the CXStrings representing the mangled symbols of the ObjC
 * class interface or implementation at the cursor.
 */
public fun clang_Cursor_getObjCManglings(`$p0`: CXCursor): Pointer<CXStringSet> =
    `clang_Cursor_getObjCManglings$mh`.invokeExact(`$p0`.`$mem`) as MemorySegment

/**
 *
 * Given a CXCursor_ModuleImportDecl cursor, return the associated module.
 */
public fun clang_Cursor_getModule(C: CXCursor): CXModule =
    `clang_Cursor_getModule$mh`.invokeExact(C.`$mem`) as MemorySegment

/**
 *
 * Given a CXFile header file, return the module that contains it, if one
 * exists.
 */
public fun clang_getModuleForFile(`$p0`: CXTranslationUnit, `$p1`: CXFile): CXModule =
    `clang_getModuleForFile$mh`.invokeExact(`$p0`, `$p1`) as MemorySegment

/**
 *
 * \param Module a module object.
 *
 * \returns the module file where the provided module object came from.
 */
public fun clang_Module_getASTFile(Module: CXModule): CXFile =
    `clang_Module_getASTFile$mh`.invokeExact(Module) as MemorySegment

/**
 *
 * \param Module a module object.
 *
 * \returns the parent of a sub-module or NULL if the given module is top-level,
 * e.g. for 'std.vector' it will return the 'std' module.
 */
public fun clang_Module_getParent(Module: CXModule): CXModule =
    `clang_Module_getParent$mh`.invokeExact(Module) as MemorySegment

/**
 *
 * \param Module a module object.
 *
 * \returns the name of the module, e.g. for the 'std.vector' sub-module it
 * will return "vector".
 */
context(SegmentAllocator)
public fun clang_Module_getName(Module: CXModule): CXString =
    CXString(`clang_Module_getName$mh`.invokeExact(this@SegmentAllocator, Module) as MemorySegment)

/**
 *
 * \param Module a module object.
 *
 * \returns the full name of the module, e.g. "std.vector".
 */
context(SegmentAllocator)
public fun clang_Module_getFullName(Module: CXModule): CXString =
    CXString(`clang_Module_getFullName$mh`.invokeExact(this@SegmentAllocator, Module) as MemorySegment)

/**
 *
 * \param Module a module object.
 *
 * \returns non-zero if the module is a system one.
 */
public fun clang_Module_isSystem(Module: CXModule): Int = `clang_Module_isSystem$mh`.invokeExact(Module) as Int

/**
 *
 * \param Module a module object.
 *
 * \returns the number of top level headers associated with this module.
 */
public fun clang_Module_getNumTopLevelHeaders(`$p0`: CXTranslationUnit, Module: CXModule): UInt =
    (`clang_Module_getNumTopLevelHeaders$mh`.invokeExact(`$p0`, Module) as Int).toUInt()

/**
 *
 * \param Module a module object.
 *
 * \param Index top level header index (zero-based).
 *
 * \returns the specified top level header associated with the module.
 */
public fun clang_Module_getTopLevelHeader(
    `$p0`: CXTranslationUnit,
    Module: CXModule,
    Index: UInt,
): CXFile = `clang_Module_getTopLevelHeader$mh`.invokeExact(`$p0`, Module, Index.toInt()) as MemorySegment

/**
 *
 * Determine if a C++ constructor is a converting constructor.
 */
public fun clang_CXXConstructor_isConvertingConstructor(C: CXCursor): UInt =
    (`clang_CXXConstructor_isConvertingConstructor$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ constructor is a copy constructor.
 */
public fun clang_CXXConstructor_isCopyConstructor(C: CXCursor): UInt =
    (`clang_CXXConstructor_isCopyConstructor$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ constructor is the default constructor.
 */
public fun clang_CXXConstructor_isDefaultConstructor(C: CXCursor): UInt =
    (`clang_CXXConstructor_isDefaultConstructor$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ constructor is a move constructor.
 */
public fun clang_CXXConstructor_isMoveConstructor(C: CXCursor): UInt =
    (`clang_CXXConstructor_isMoveConstructor$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ field is declared 'mutable'.
 */
public fun clang_CXXField_isMutable(C: CXCursor): UInt =
    (`clang_CXXField_isMutable$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ method is declared '= default'.
 */
public fun clang_CXXMethod_isDefaulted(C: CXCursor): UInt =
    (`clang_CXXMethod_isDefaulted$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ method is declared '= delete'.
 */
public fun clang_CXXMethod_isDeleted(C: CXCursor): UInt =
    (`clang_CXXMethod_isDeleted$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function or member function template is
 * pure virtual.
 */
public fun clang_CXXMethod_isPureVirtual(C: CXCursor): UInt =
    (`clang_CXXMethod_isPureVirtual$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function or member function template is
 * declared 'static'.
 */
public fun clang_CXXMethod_isStatic(C: CXCursor): UInt =
    (`clang_CXXMethod_isStatic$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function or member function template is
 * explicitly declared 'virtual' or if it overrides a virtual method from
 * one of the base classes.
 */
public fun clang_CXXMethod_isVirtual(C: CXCursor): UInt =
    (`clang_CXXMethod_isVirtual$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function is a copy-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A copy-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X`, `X&`, `const X&`, `volatile X&` or `const
 * > volatile X&`.
 *
 * That is, for example, the `operator=` in:
 *
 * class Foo {
 * bool operator=(const volatile Foo&);
 * };
 *
 * Is a copy-assignment operator, while the `operator=` in:
 *
 * class Bar {
 * bool operator=(const int&);
 * };
 *
 * Is not.
 */
public fun clang_CXXMethod_isCopyAssignmentOperator(C: CXCursor): UInt =
    (`clang_CXXMethod_isCopyAssignmentOperator$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function is a move-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A move-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X&&`, `const X&&`, `volatile X&&` or `const
 * > volatile X&&`.
 *
 * That is, for example, the `operator=` in:
 *
 * class Foo {
 * bool operator=(const volatile Foo&&);
 * };
 *
 * Is a move-assignment operator, while the `operator=` in:
 *
 * class Bar {
 * bool operator=(const int&&);
 * };
 *
 * Is not.
 */
public fun clang_CXXMethod_isMoveAssignmentOperator(C: CXCursor): UInt =
    (`clang_CXXMethod_isMoveAssignmentOperator$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determines if a C++ constructor or conversion function was declared
 * explicit, returning 1 if such is the case and 0 otherwise.
 *
 * Constructors or conversion functions are declared explicit through
 * the use of the explicit specifier.
 *
 * For example, the following constructor and conversion function are
 * not explicit as they lack the explicit specifier:
 *
 * class Foo {
 * Foo();
 * operator int();
 * };
 *
 * While the following constructor and conversion function are
 * explicit as they are declared with the explicit specifier.
 *
 * class Foo {
 * explicit Foo();
 * explicit operator int();
 * };
 *
 * This function will return 0 when given a cursor pointing to one of
 * the former declarations and it will return 1 for a cursor pointing
 * to the latter declarations.
 *
 * The explicit specifier allows the user to specify a
 * conditional compile-time expression whose value decides
 * whether the marked element is explicit or not.
 *
 * For example:
 *
 * constexpr bool foo(int i) { return i % 2 == 0; }
 *
 * class Foo {
 * explicit(foo(1)) Foo();
 * explicit(foo(2)) operator int();
 * }
 *
 * This function will return 0 for the constructor and 1 for
 * the conversion function.
 */
public fun clang_CXXMethod_isExplicit(C: CXCursor): UInt =
    (`clang_CXXMethod_isExplicit$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ record is abstract, i.e. whether a class or struct
 * has a pure virtual member function.
 */
public fun clang_CXXRecord_isAbstract(C: CXCursor): UInt =
    (`clang_CXXRecord_isAbstract$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if an enum declaration refers to a scoped enum.
 */
public fun clang_EnumDecl_isScoped(C: CXCursor): UInt =
    (`clang_EnumDecl_isScoped$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Determine if a C++ member function or member function template is
 * declared 'const'.
 */
public fun clang_CXXMethod_isConst(C: CXCursor): UInt =
    (`clang_CXXMethod_isConst$mh`.invokeExact(C.`$mem`) as Int).toUInt()

/**
 *
 * Given a cursor that represents a template, determine
 * the cursor kind of the specializations would be generated by instantiating
 * the template.
 *
 * This routine can be used to determine what flavor of function template,
 * class template, or class template partial specialization is stored in the
 * cursor. For example, it can describe whether a class template cursor is
 * declared with "struct", "class" or "union".
 *
 * \param C The cursor to query. This cursor should represent a template
 * declaration.
 *
 * \returns The cursor kind of the specializations that would be generated
 * by instantiating the template \p C. If \p C is not a template, returns
 * \c CXCursor_NoDeclFound.
 */
public fun clang_getTemplateCursorKind(C: CXCursor): CXCursorKind =
    CXCursorKind.fromInt(`clang_getTemplateCursorKind$mh`.invokeExact(C.`$mem`) as Int)

/**
 *
 * Given a cursor that may represent a specialization or instantiation
 * of a template, retrieve the cursor that represents the template that it
 * specializes or from which it was instantiated.
 *
 * This routine determines the template involved both for explicit
 * specializations of templates and for implicit instantiations of the template,
 * both of which are referred to as "specializations". For a class template
 * specialization (e.g., \c std::vector<bool>), this routine will return
 * either the primary template (\c std::vector) or, if the specialization was
 * instantiated from a class template partial specialization, the class template
 * partial specialization. For a class template partial specialization and a
 * function template specialization (including instantiations), this
 * this routine will return the specialized template.
 *
 * For members of a class template (e.g., member functions, member classes, or
 * static data members), returns the specialized or instantiated member.
 * Although not strictly "templates" in the C++ language, members of class
 * templates have the same notions of specializations and instantiations that
 * templates do, so this routine treats them similarly.
 *
 * \param C A cursor that may be a specialization of a template or a member
 * of a template.
 *
 * \returns If the given cursor is a specialization or instantiation of a
 * template or a member thereof, the template or member that it specializes or
 * from which it was instantiated. Otherwise, returns a NULL cursor.
 */
context(SegmentAllocator)
public fun clang_getSpecializedCursorTemplate(C: CXCursor): CXCursor =
    CXCursor(`clang_getSpecializedCursorTemplate$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * Given a cursor that references something else, return the source range
 * covering that reference.
 *
 * \param C A cursor pointing to a member reference, a declaration reference, or
 * an operator call.
 * \param NameFlags A bitset with three independent flags:
 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
 * CXNameRange_WantSinglePiece.
 * \param PieceIndex For contiguous names or when passing the flag
 * CXNameRange_WantSinglePiece, only one piece with index 0 is
 * available. When the CXNameRange_WantSinglePiece flag is not passed for a
 * non-contiguous names, this index can be used to retrieve the individual
 * pieces of the name. See also CXNameRange_WantSinglePiece.
 *
 * \returns The piece of the name pointed to by the given cursor. If there is no
 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
 */
context(SegmentAllocator)
public fun clang_getCursorReferenceNameRange(
    C: CXCursor,
    NameFlags: UInt,
    PieceIndex: UInt,
): CXSourceRange = CXSourceRange(
    `clang_getCursorReferenceNameRange$mh`.invokeExact(
        this@SegmentAllocator,
        C.`$mem`,
        NameFlags.toInt(),
        PieceIndex.toInt(),
    ) as MemorySegment
)

/**
 *
 * Get the raw lexical token starting with the given location.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Location the source location with which the token starts.
 *
 * \returns The token starting with the given location or NULL if no such token
 * exist. The returned pointer must be freed with clang_disposeTokens before the
 * translation unit is destroyed.
 */
public fun clang_getToken(TU: CXTranslationUnit, Location: CXSourceLocation): Pointer<CXToken> =
    `clang_getToken$mh`.invokeExact(TU, Location.`$mem`) as MemorySegment

/**
 *
 * Determine the kind of the given token.
 */
public fun clang_getTokenKind(`$p0`: CXToken): CXTokenKind =
    CXTokenKind.fromInt(`clang_getTokenKind$mh`.invokeExact(`$p0`.`$mem`) as Int)

/**
 *
 * Determine the spelling of the given token.
 *
 * The spelling of a token is the textual representation of that token, e.g.,
 * the text of an identifier or keyword.
 */
context(SegmentAllocator)
public fun clang_getTokenSpelling(`$p0`: CXTranslationUnit, `$p1`: CXToken): CXString =
    CXString(`clang_getTokenSpelling$mh`.invokeExact(this@SegmentAllocator, `$p0`, `$p1`.`$mem`) as MemorySegment)

/**
 *
 * Retrieve the source location of the given token.
 */
context(SegmentAllocator)
public fun clang_getTokenLocation(`$p0`: CXTranslationUnit, `$p1`: CXToken): CXSourceLocation = CXSourceLocation(
    `clang_getTokenLocation$mh`.invokeExact(
        this@SegmentAllocator,
        `$p0`,
        `$p1`.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Retrieve a source range that covers the given token.
 */
context(SegmentAllocator)
public fun clang_getTokenExtent(`$p0`: CXTranslationUnit, `$p1`: CXToken): CXSourceRange =
    CXSourceRange(`clang_getTokenExtent$mh`.invokeExact(this@SegmentAllocator, `$p0`, `$p1`.`$mem`) as MemorySegment)

/**
 *
 * Tokenize the source code described by the given range into raw
 * lexical tokens.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Range the source range in which text should be tokenized. All of the
 * tokens produced by tokenization will fall within this source range,
 *
 * \param Tokens this pointer will be set to point to the array of tokens
 * that occur within the given source range. The returned pointer must be
 * freed with clang_disposeTokens() before the translation unit is destroyed.
 *
 * \param NumTokens will be set to the number of tokens in the \c *Tokens
 * array.
 */
public fun clang_tokenize(
    TU: CXTranslationUnit,
    Range: CXSourceRange,
    Tokens: Pointer<Pointer<CXToken>>,
    NumTokens: Pointer<UInt>,
): Unit = `clang_tokenize$mh`.invokeExact(TU, Range.`$mem`, Tokens, NumTokens) as Unit

/**
 *
 * Annotate the given set of tokens by providing cursors for each token
 * that can be mapped to a specific entity within the abstract syntax tree.
 *
 * This token-annotation routine is equivalent to invoking
 * clang_getCursor() for the source locations of each of the
 * tokens. The cursors provided are filtered, so that only those
 * cursors that have a direct correspondence to the token are
 * accepted. For example, given a function call \c f(x),
 * clang_getCursor() would provide the following cursors:
 *
 * * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
 * * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
 * * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
 *
 * Only the first and last of these cursors will occur within the
 * annotate, since the tokens "f" and "x' directly refer to a function
 * and a variable, respectively, but the parentheses are just a small
 * part of the full syntax of the function call expression, which is
 * not provided as an annotation.
 *
 * \param TU the translation unit that owns the given tokens.
 *
 * \param Tokens the set of tokens to annotate.
 *
 * \param NumTokens the number of tokens in \p Tokens.
 *
 * \param Cursors an array of \p NumTokens cursors, whose contents will be
 * replaced with the cursors corresponding to each token.
 */
public fun clang_annotateTokens(
    TU: CXTranslationUnit,
    Tokens: Pointer<CXToken>,
    NumTokens: UInt,
    Cursors: Pointer<CXCursor>,
): Unit = `clang_annotateTokens$mh`.invokeExact(TU, Tokens, NumTokens.toInt(), Cursors) as Unit

/**
 *
 * Free the given set of tokens.
 */
public fun clang_disposeTokens(
    TU: CXTranslationUnit,
    Tokens: Pointer<CXToken>,
    NumTokens: UInt,
): Unit = `clang_disposeTokens$mh`.invokeExact(TU, Tokens, NumTokens.toInt()) as Unit

/**
 * for debug/testing
 */
context(SegmentAllocator)
public fun clang_getCursorKindSpelling(Kind: CXCursorKind): CXString =
    CXString(`clang_getCursorKindSpelling$mh`.invokeExact(this@SegmentAllocator, Kind.value) as MemorySegment)

public fun clang_getDefinitionSpellingAndExtent(
    `$p0`: CXCursor,
    startBuf: Pointer<Pointer<Byte>>,
    endBuf: Pointer<Pointer<Byte>>,
    startLine: Pointer<UInt>,
    startColumn: Pointer<UInt>,
    endLine: Pointer<UInt>,
    endColumn: Pointer<UInt>,
): Unit = `clang_getDefinitionSpellingAndExtent$mh`.invokeExact(
    `$p0`.`$mem`,
    startBuf,
    endBuf,
    startLine,
    startColumn,
    endLine,
    endColumn,
) as Unit

public fun clang_enableStackTraces(): Unit = `clang_enableStackTraces$mh`.invokeExact() as Unit

public fun clang_executeOnThread(
    fn: clang_executeOnThread_fn,
    user_data: Pointer<Unit>,
    stack_size: UInt,
): Unit = `clang_executeOnThread$mh`.invokeExact(fn, user_data, stack_size.toInt()) as Unit

/**
 *
 * Determine the kind of a particular chunk within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the kind of the chunk at the index \c chunk_number.
 */
public fun clang_getCompletionChunkKind(
    completion_string: CXCompletionString,
    chunk_number: UInt
): CXCompletionChunkKind = CXCompletionChunkKind.fromInt(
    `clang_getCompletionChunkKind$mh`.invokeExact(
        completion_string,
        chunk_number.toInt(),
    ) as Int
)

/**
 *
 * Retrieve the text associated with a particular chunk within a
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the text associated with the chunk at index \c chunk_number.
 */
context(SegmentAllocator)
public fun clang_getCompletionChunkText(completion_string: CXCompletionString, chunk_number: UInt): CXString = CXString(
    `clang_getCompletionChunkText$mh`.invokeExact(
        this@SegmentAllocator,
        completion_string,
        chunk_number.toInt(),
    ) as MemorySegment
)

/**
 *
 * Retrieve the completion string associated with a particular chunk
 * within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the completion string associated with the chunk at index
 * \c chunk_number.
 */
public fun clang_getCompletionChunkCompletionString(
    completion_string: CXCompletionString,
    chunk_number: UInt
): CXCompletionString =
    `clang_getCompletionChunkCompletionString$mh`.invokeExact(completion_string, chunk_number.toInt()) as MemorySegment

/**
 *
 * Retrieve the number of chunks in the given code-completion string.
 */
public fun clang_getNumCompletionChunks(completion_string: CXCompletionString): UInt =
    (`clang_getNumCompletionChunks$mh`.invokeExact(completion_string) as Int).toUInt()

/**
 *
 * Determine the priority of this code completion.
 *
 * The priority of a code completion indicates how likely it is that this
 * particular completion is the completion that the user will select. The
 * priority is selected by various internal heuristics.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The priority of this completion string. Smaller values indicate
 * higher-priority (more likely) completions.
 */
public fun clang_getCompletionPriority(completion_string: CXCompletionString): UInt =
    (`clang_getCompletionPriority$mh`.invokeExact(completion_string) as Int).toUInt()

/**
 *
 * Determine the availability of the entity that this code-completion
 * string refers to.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The availability of the completion string.
 */
public fun clang_getCompletionAvailability(completion_string: CXCompletionString): CXAvailabilityKind =
    CXAvailabilityKind.fromInt(`clang_getCompletionAvailability$mh`.invokeExact(completion_string) as Int)

/**
 *
 * Retrieve the number of annotations associated with the given
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \returns the number of annotations associated with the given completion
 * string.
 */
public fun clang_getCompletionNumAnnotations(completion_string: CXCompletionString): UInt =
    (`clang_getCompletionNumAnnotations$mh`.invokeExact(completion_string) as Int).toUInt()

/**
 *
 * Retrieve the annotation associated with the given completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param annotation_number the 0-based index of the annotation of the
 * completion string.
 *
 * \returns annotation string associated with the completion at index
 * \c annotation_number, or a NULL string if that annotation is not available.
 */
context(SegmentAllocator)
public fun clang_getCompletionAnnotation(completion_string: CXCompletionString, annotation_number: UInt): CXString =
    CXString(
        `clang_getCompletionAnnotation$mh`.invokeExact(
            this@SegmentAllocator,
            completion_string,
            annotation_number.toInt(),
        ) as MemorySegment
    )

/**
 *
 * Retrieve the parent context of the given completion string.
 *
 * The parent context of a completion string is the semantic parent of
 * the declaration (if any) that the code completion represents. For example,
 * a code completion for an Objective-C method would have the method's class
 * or protocol as its context.
 *
 * \param completion_string The code completion string whose parent is
 * being queried.
 *
 * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
 *
 * \returns The name of the completion parent, e.g., "NSObject" if
 * the completion string represents a method in the NSObject class.
 */
context(SegmentAllocator)
public fun clang_getCompletionParent(completion_string: CXCompletionString, kind: Pointer<CXCursorKind>): CXString =
    CXString(
        `clang_getCompletionParent$mh`.invokeExact(
            this@SegmentAllocator,
            completion_string,
            kind,
        ) as MemorySegment
    )

/**
 *
 * Retrieve the brief documentation comment attached to the declaration
 * that corresponds to the given completion string.
 */
context(SegmentAllocator)
public fun clang_getCompletionBriefComment(completion_string: CXCompletionString): CXString = CXString(
    `clang_getCompletionBriefComment$mh`.invokeExact(
        this@SegmentAllocator,
        completion_string,
    ) as MemorySegment
)

/**
 *
 * Retrieve a completion string for an arbitrary declaration or macro
 * definition cursor.
 *
 * \param cursor The cursor to query.
 *
 * \returns A non-context-sensitive completion string for declaration and macro
 * definition cursors, or NULL for other kinds of cursors.
 */
public fun clang_getCursorCompletionString(cursor: CXCursor): CXCompletionString =
    `clang_getCursorCompletionString$mh`.invokeExact(cursor.`$mem`) as MemorySegment

/**
 *
 * Retrieve the number of fix-its for the given completion index.
 *
 * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts
 * option was set.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \return The number of fix-its which must be applied before the completion at
 * completion_index can be applied
 */
public fun clang_getCompletionNumFixIts(results: Pointer<CXCodeCompleteResults>, completion_index: UInt): UInt =
    (`clang_getCompletionNumFixIts$mh`.invokeExact(results, completion_index.toInt()) as Int).toUInt()

/**
 *
 * Fix-its that *must* be applied before inserting the text for the
 * corresponding completion.
 *
 * By default, clang_codeCompleteAt() only returns completions with empty
 * fix-its. Extra completions with non-empty fix-its should be explicitly
 * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.
 *
 * For the clients to be able to compute position of the cursor after applying
 * fix-its, the following conditions are guaranteed to hold for
 * replacement_range of the stored fix-its:
 * - Ranges in the fix-its are guaranteed to never contain the completion
 * point (or identifier under completion point, if any) inside them, except
 * at the start or at the end of the range.
 * - If a fix-it range starts or ends with completion point (or starts or
 * ends after the identifier under completion point), it will contain at
 * least one character. It allows to unambiguously recompute completion
 * point after applying the fix-it.
 *
 * The intuition is that provided fix-its change code around the identifier we
 * complete, but are not allowed to touch the identifier itself or the
 * completion point. One example of completions with corrections are the ones
 * replacing '.' with '->' and vice versa:
 *
 * std::unique_ptr<std::vector<int>> vec_ptr;
 * In 'vec_ptr.^', one of the completions is 'push_back', it requires
 * replacing '.' with '->'.
 * In 'vec_ptr->^', one of the completions is 'release', it requires
 * replacing '->' with '.'.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \param fixit_index The index of the fix-it for the completion at
 * completion_index
 *
 * \param replacement_range The fix-it range that must be replaced before the
 * completion at completion_index can be applied
 *
 * \returns The fix-it string that must replace the code at replacement_range
 * before the completion at completion_index can be applied
 */
context(SegmentAllocator)
public fun clang_getCompletionFixIt(
    results: Pointer<CXCodeCompleteResults>,
    completion_index: UInt,
    fixit_index: UInt,
    replacement_range: Pointer<CXSourceRange>,
): CXString = CXString(
    `clang_getCompletionFixIt$mh`.invokeExact(
        this@SegmentAllocator,
        results,
        completion_index.toInt(),
        fixit_index.toInt(),
        replacement_range,
    ) as MemorySegment
)

/**
 *
 * Returns a default set of code-completion options that can be
 * passed to\c clang_codeCompleteAt().
 */
public fun clang_defaultCodeCompleteOptions(): UInt =
    (`clang_defaultCodeCompleteOptions$mh`.invokeExact() as Int).toUInt()

/**
 *
 * Perform code completion at a given location in a translation unit.
 *
 * This function performs code completion at a particular file, line, and
 * column within source code, providing results that suggest potential
 * code snippets based on the context of the completion. The basic model
 * for code completion is that Clang will parse a complete source file,
 * performing syntax checking up to the location where code-completion has
 * been requested. At that point, a special code-completion token is passed
 * to the parser, which recognizes this token and determines, based on the
 * current location in the C/Objective-C/C++ grammar and the state of
 * semantic analysis, what completions to provide. These completions are
 * returned via a new \c CXCodeCompleteResults structure.
 *
 * Code completion itself is meant to be triggered by the client when the
 * user types punctuation characters or whitespace, at which point the
 * code-completion location will coincide with the cursor. For example, if \c p
 * is a pointer, code-completion might be triggered after the "-" and then
 * after the ">" in \c p->. When the code-completion location is after the ">",
 * the completion results will provide, e.g., the members of the struct that
 * "p" points to. The client is responsible for placing the cursor at the
 * beginning of the token currently being typed, then filtering the results
 * based on the contents of the token. For example, when code-completing for
 * the expression \c p->get, the client should provide the location just after
 * the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
 * client can filter the results based on the current token text ("get"), only
 * showing those results that start with "get". The intent of this interface
 * is to separate the relatively high-latency acquisition of code-completion
 * results from the filtering of results on a per-character basis, which must
 * have a lower latency.
 *
 * \param TU The translation unit in which code-completion should
 * occur. The source files for this translation unit need not be
 * completely up-to-date (and the contents of those source files may
 * be overridden via \p unsaved_files). Cursors referring into the
 * translation unit may be invalidated by this invocation.
 *
 * \param complete_filename The name of the source file where code
 * completion should be performed. This filename may be any file
 * included in the translation unit.
 *
 * \param complete_line The line at which code-completion should occur.
 *
 * \param complete_column The column at which code-completion should occur.
 * Note that the column should point just after the syntactic construct that
 * initiated code completion, and not in the middle of a lexical token.
 *
 * \param unsaved_files the Files that have not yet been saved to disk
 * but may be required for parsing or code completion, including the
 * contents of those files.  The contents and name of these files (as
 * specified by CXUnsavedFile) are copied when necessary, so the
 * client only needs to guarantee their validity until the call to
 * this function returns.
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options Extra options that control the behavior of code
 * completion, expressed as a bitwise OR of the enumerators of the
 * CXCodeComplete_Flags enumeration. The
 * \c clang_defaultCodeCompleteOptions() function returns a default set
 * of code-completion options.
 *
 * \returns If successful, a new \c CXCodeCompleteResults structure
 * containing code-completion results, which should eventually be
 * freed with \c clang_disposeCodeCompleteResults(). If code
 * completion fails, returns NULL.
 */
public fun clang_codeCompleteAt(
    TU: CXTranslationUnit,
    complete_filename: Pointer<Byte>,
    complete_line: UInt,
    complete_column: UInt,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    options: UInt,
): Pointer<CXCodeCompleteResults> = `clang_codeCompleteAt$mh`.invokeExact(
    TU,
    complete_filename,
    complete_line.toInt(),
    complete_column.toInt(),
    unsaved_files,
    num_unsaved_files.toInt(),
    options.toInt(),
) as MemorySegment

/**
 *
 * Sort the code-completion results in case-insensitive alphabetical
 * order.
 *
 * \param Results The set of results to sort.
 * \param NumResults The number of results in \p Results.
 */
public fun clang_sortCodeCompletionResults(Results: Pointer<CXCompletionResult>, NumResults: UInt): Unit =
    `clang_sortCodeCompletionResults$mh`.invokeExact(Results, NumResults.toInt()) as Unit

/**
 *
 * Free the given set of code-completion results.
 */
public fun clang_disposeCodeCompleteResults(Results: Pointer<CXCodeCompleteResults>): Unit =
    `clang_disposeCodeCompleteResults$mh`.invokeExact(Results) as Unit

/**
 *
 * Determine the number of diagnostics produced prior to the
 * location where code completion was performed.
 */
public fun clang_codeCompleteGetNumDiagnostics(Results: Pointer<CXCodeCompleteResults>): UInt =
    (`clang_codeCompleteGetNumDiagnostics$mh`.invokeExact(Results) as Int).toUInt()

/**
 *
 * Retrieve a diagnostic associated with the given code completion.
 *
 * \param Results the code completion results to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public fun clang_codeCompleteGetDiagnostic(Results: Pointer<CXCodeCompleteResults>, Index: UInt): CXDiagnostic =
    `clang_codeCompleteGetDiagnostic$mh`.invokeExact(Results, Index.toInt()) as MemorySegment

/**
 *
 * Determines what completions are appropriate for the context
 * the given code completion.
 *
 * \param Results the code completion results to query
 *
 * \returns the kinds of completions that are appropriate for use
 * along with the given code completion results.
 */
public fun clang_codeCompleteGetContexts(Results: Pointer<CXCodeCompleteResults>): ULong =
    (`clang_codeCompleteGetContexts$mh`.invokeExact(Results) as Long).toULong()

/**
 *
 * Returns the cursor kind for the container for the current code
 * completion context. The container is only guaranteed to be set for
 * contexts where a container exists (i.e. member accesses or Objective-C
 * message sends); if there is not a container, this function will return
 * CXCursor_InvalidCode.
 *
 * \param Results the code completion results to query
 *
 * \param IsIncomplete on return, this value will be false if Clang has complete
 * information about the container. If Clang does not have complete
 * information, this value will be true.
 *
 * \returns the container kind, or CXCursor_InvalidCode if there is not a
 * container
 */
public fun clang_codeCompleteGetContainerKind(
    Results: Pointer<CXCodeCompleteResults>,
    IsIncomplete: Pointer<UInt>
): CXCursorKind =
    CXCursorKind.fromInt(`clang_codeCompleteGetContainerKind$mh`.invokeExact(Results, IsIncomplete) as Int)

/**
 *
 * Returns the USR for the container for the current code completion
 * context. If there is not a container for the current context, this
 * function will return the empty string.
 *
 * \param Results the code completion results to query
 *
 * \returns the USR for the container
 */
context(SegmentAllocator)
public fun clang_codeCompleteGetContainerUSR(Results: Pointer<CXCodeCompleteResults>): CXString =
    CXString(`clang_codeCompleteGetContainerUSR$mh`.invokeExact(this@SegmentAllocator, Results) as MemorySegment)

/**
 *
 * Returns the currently-entered selector for an Objective-C message
 * send, formatted like "initWithFoo:bar:". Only guaranteed to return a
 * non-empty string for CXCompletionContext_ObjCInstanceMessage and
 * CXCompletionContext_ObjCClassMessage.
 *
 * \param Results the code completion results to query
 *
 * \returns the selector (or partial selector) that has been entered thus far
 * for an Objective-C message send.
 */
context(SegmentAllocator)
public fun clang_codeCompleteGetObjCSelector(Results: Pointer<CXCodeCompleteResults>): CXString =
    CXString(`clang_codeCompleteGetObjCSelector$mh`.invokeExact(this@SegmentAllocator, Results) as MemorySegment)

/**
 *
 * Return a version string, suitable for showing to a user, but not
 * intended to be parsed (the format is not guaranteed to be stable).
 */
context(SegmentAllocator)
public fun clang_getClangVersion(): CXString =
    CXString(`clang_getClangVersion$mh`.invokeExact(this@SegmentAllocator) as MemorySegment)

/**
 *
 * Enable/disable crash recovery.
 *
 * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
 * value enables crash recovery, while 0 disables it.
 */
public fun clang_toggleCrashRecovery(isEnabled: UInt): Unit =
    `clang_toggleCrashRecovery$mh`.invokeExact(isEnabled.toInt()) as Unit

/**
 *
 * Visit the set of preprocessor inclusions in a translation unit.
 * The visitor function is called with the provided data for every included
 * file.  This does not include headers included by the PCH file (unless one
 * is inspecting the inclusions in the PCH file itself).
 */
public fun clang_getInclusions(
    tu: CXTranslationUnit,
    visitor: CXInclusionVisitor,
    client_data: CXClientData,
): Unit = `clang_getInclusions$mh`.invokeExact(tu, visitor, client_data) as Unit

/**
 *
 * If cursor is a statement declaration tries to evaluate the
 * statement and if its variable, tries to evaluate its initializer,
 * into its corresponding type.
 * If it's an expression, tries to evaluate the expression.
 */
public fun clang_Cursor_Evaluate(C: CXCursor): CXEvalResult =
    `clang_Cursor_Evaluate$mh`.invokeExact(C.`$mem`) as MemorySegment

/**
 *
 * Returns the kind of the evaluated result.
 */
public fun clang_EvalResult_getKind(E: CXEvalResult): CXEvalResultKind =
    CXEvalResultKind.fromInt(`clang_EvalResult_getKind$mh`.invokeExact(E) as Int)

/**
 *
 * Returns the evaluation result as integer if the
 * kind is Int.
 */
public fun clang_EvalResult_getAsInt(E: CXEvalResult): Int = `clang_EvalResult_getAsInt$mh`.invokeExact(E) as Int

/**
 *
 * Returns the evaluation result as a long long integer if the
 * kind is Int. This prevents overflows that may happen if the result is
 * returned with clang_EvalResult_getAsInt.
 */
public fun clang_EvalResult_getAsLongLong(E: CXEvalResult): Long =
    `clang_EvalResult_getAsLongLong$mh`.invokeExact(E) as Long

/**
 *
 * Returns a non-zero value if the kind is Int and the evaluation
 * result resulted in an unsigned integer.
 */
public fun clang_EvalResult_isUnsignedInt(E: CXEvalResult): UInt =
    (`clang_EvalResult_isUnsignedInt$mh`.invokeExact(E) as Int).toUInt()

/**
 *
 * Returns the evaluation result as an unsigned integer if
 * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
 */
public fun clang_EvalResult_getAsUnsigned(E: CXEvalResult): ULong =
    (`clang_EvalResult_getAsUnsigned$mh`.invokeExact(E) as Long).toULong()

/**
 *
 * Returns the evaluation result as double if the
 * kind is double.
 */
public fun clang_EvalResult_getAsDouble(E: CXEvalResult): Double =
    `clang_EvalResult_getAsDouble$mh`.invokeExact(E) as Double

/**
 *
 * Returns the evaluation result as a constant string if the
 * kind is other than Int or float. User must not free this pointer,
 * instead call clang_EvalResult_dispose on the CXEvalResult returned
 * by clang_Cursor_Evaluate.
 */
public fun clang_EvalResult_getAsStr(E: CXEvalResult): Pointer<Byte> =
    `clang_EvalResult_getAsStr$mh`.invokeExact(E) as MemorySegment

/**
 *
 * Disposes the created Eval memory.
 */
public fun clang_EvalResult_dispose(E: CXEvalResult): Unit = `clang_EvalResult_dispose$mh`.invokeExact(E) as Unit

/**
 *
 * Retrieve a remapping.
 *
 * \param path the path that contains metadata about remappings.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
public fun clang_getRemappings(path: Pointer<Byte>): CXRemapping =
    `clang_getRemappings$mh`.invokeExact(path) as MemorySegment

/**
 *
 * Retrieve a remapping.
 *
 * \param filePaths pointer to an array of file paths containing remapping info.
 *
 * \param numFiles number of file paths.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
public fun clang_getRemappingsFromFileList(filePaths: Pointer<Pointer<Byte>>, numFiles: UInt): CXRemapping =
    `clang_getRemappingsFromFileList$mh`.invokeExact(filePaths, numFiles.toInt()) as MemorySegment

/**
 *
 * Determine the number of remappings.
 */
public fun clang_remap_getNumFiles(`$p0`: CXRemapping): UInt =
    (`clang_remap_getNumFiles$mh`.invokeExact(`$p0`) as Int).toUInt()

/**
 *
 * Get the original and the associated filename from the remapping.
 *
 * \param original If non-NULL, will be set to the original filename.
 *
 * \param transformed If non-NULL, will be set to the filename that the original
 * is associated with.
 */
public fun clang_remap_getFilenames(
    `$p0`: CXRemapping,
    index: UInt,
    original: Pointer<CXString>,
    transformed: Pointer<CXString>,
): Unit = `clang_remap_getFilenames$mh`.invokeExact(`$p0`, index.toInt(), original, transformed) as Unit

/**
 *
 * Dispose the remapping.
 */
public fun clang_remap_dispose(`$p0`: CXRemapping): Unit = `clang_remap_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Find references of a declaration in a specific file.
 *
 * \param cursor pointing to a declaration or a reference of one.
 *
 * \param file to search for references.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each reference found.
 * The CXSourceRange will point inside the file; if the reference is inside
 * a macro (and not a macro argument) the CXSourceRange will be invalid.
 *
 * \returns one of the CXResult enumerators.
 */
public fun clang_findReferencesInFile(
    cursor: CXCursor,
    `file`: CXFile,
    visitor: CXCursorAndRangeVisitor,
): CXResult =
    CXResult.fromInt(`clang_findReferencesInFile$mh`.invokeExact(cursor.`$mem`, `file`, visitor.`$mem`) as Int)

/**
 *
 * Find #import/#include directives in a specific file.
 *
 * \param TU translation unit containing the file to query.
 *
 * \param file to search for #import/#include directives.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each directive found.
 *
 * \returns one of the CXResult enumerators.
 */
public fun clang_findIncludesInFile(
    TU: CXTranslationUnit,
    `file`: CXFile,
    visitor: CXCursorAndRangeVisitor,
): CXResult = CXResult.fromInt(`clang_findIncludesInFile$mh`.invokeExact(TU, `file`, visitor.`$mem`) as Int)

public fun clang_findReferencesInFileWithBlock(
    `$p0`: CXCursor,
    `$p1`: CXFile,
    `$p2`: CXCursorAndRangeVisitorBlock,
): CXResult = CXResult.fromInt(`clang_findReferencesInFileWithBlock$mh`.invokeExact(`$p0`.`$mem`, `$p1`, `$p2`) as Int)

public fun clang_findIncludesInFileWithBlock(
    `$p0`: CXTranslationUnit,
    `$p1`: CXFile,
    `$p2`: CXCursorAndRangeVisitorBlock,
): CXResult = CXResult.fromInt(`clang_findIncludesInFileWithBlock$mh`.invokeExact(`$p0`, `$p1`, `$p2`) as Int)

public fun clang_index_isEntityObjCContainerKind(`$p0`: CXIdxEntityKind): Int =
    `clang_index_isEntityObjCContainerKind$mh`.invokeExact(`$p0`.value) as Int

public fun clang_index_getObjCContainerDeclInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxObjCContainerDeclInfo> =
    `clang_index_getObjCContainerDeclInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getObjCInterfaceDeclInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxObjCInterfaceDeclInfo> =
    `clang_index_getObjCInterfaceDeclInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getObjCCategoryDeclInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxObjCCategoryDeclInfo> =
    `clang_index_getObjCCategoryDeclInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getObjCProtocolRefListInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxObjCProtocolRefListInfo> =
    `clang_index_getObjCProtocolRefListInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getObjCPropertyDeclInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxObjCPropertyDeclInfo> =
    `clang_index_getObjCPropertyDeclInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getIBOutletCollectionAttrInfo(`$p0`: Pointer<CXIdxAttrInfo>): Pointer<CXIdxIBOutletCollectionAttrInfo> =
    `clang_index_getIBOutletCollectionAttrInfo$mh`.invokeExact(`$p0`) as MemorySegment

public fun clang_index_getCXXClassDeclInfo(`$p0`: Pointer<CXIdxDeclInfo>): Pointer<CXIdxCXXClassDeclInfo> =
    `clang_index_getCXXClassDeclInfo$mh`.invokeExact(`$p0`) as MemorySegment

/**
 *
 * For retrieving a custom CXIdxClientContainer attached to a
 * container.
 */
public fun clang_index_getClientContainer(`$p0`: Pointer<CXIdxContainerInfo>): CXIdxClientContainer =
    `clang_index_getClientContainer$mh`.invokeExact(`$p0`) as MemorySegment

/**
 *
 * For setting a custom CXIdxClientContainer attached to a
 * container.
 */
public fun clang_index_setClientContainer(`$p0`: Pointer<CXIdxContainerInfo>, `$p1`: CXIdxClientContainer): Unit =
    `clang_index_setClientContainer$mh`.invokeExact(`$p0`, `$p1`) as Unit

/**
 *
 * For retrieving a custom CXIdxClientEntity attached to an entity.
 */
public fun clang_index_getClientEntity(`$p0`: Pointer<CXIdxEntityInfo>): CXIdxClientEntity =
    `clang_index_getClientEntity$mh`.invokeExact(`$p0`) as MemorySegment

/**
 *
 * For setting a custom CXIdxClientEntity attached to an entity.
 */
public fun clang_index_setClientEntity(`$p0`: Pointer<CXIdxEntityInfo>, `$p1`: CXIdxClientEntity): Unit =
    `clang_index_setClientEntity$mh`.invokeExact(`$p0`, `$p1`) as Unit

/**
 *
 * An indexing action/session, to be applied to one or multiple
 * translation units.
 *
 * \param CIdx The index object with which the index action will be associated.
 */
public fun clang_IndexAction_create(CIdx: CXIndex): CXIndexAction =
    `clang_IndexAction_create$mh`.invokeExact(CIdx) as MemorySegment

/**
 *
 * Destroy the given index action.
 *
 * The index action must not be destroyed until all of the translation units
 * created within that index action have been destroyed.
 */
public fun clang_IndexAction_dispose(`$p0`: CXIndexAction): Unit =
    `clang_IndexAction_dispose$mh`.invokeExact(`$p0`) as Unit

/**
 *
 * Index the given source file and the translation unit corresponding
 * to that file via callbacks implemented through #IndexerCallbacks.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the invoked callbacks.
 *
 * \param index_callbacks Pointer to indexing callbacks that the client
 * implements.
 *
 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets
 * passed in index_callbacks.
 *
 * \param index_options A bitmask of options that affects how indexing is
 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
 *
 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be
 * reused after indexing is finished. Set to \c NULL if you do not require it.
 *
 * \returns 0 on success or if there were errors from which the compiler could
 * recover.  If there is a failure from which there is no recovery, returns
 * a non-zero \c CXErrorCode.
 *
 * The rest of the parameters are the same as #clang_parseTranslationUnit.
 */
public fun clang_indexSourceFile(
    `$p0`: CXIndexAction,
    client_data: CXClientData,
    index_callbacks: Pointer<IndexerCallbacks>,
    index_callbacks_size: UInt,
    index_options: UInt,
    source_filename: Pointer<Byte>,
    command_line_args: Pointer<Pointer<Byte>>,
    num_command_line_args: Int,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    out_TU: Pointer<CXTranslationUnit>,
    TU_options: UInt,
): Int = `clang_indexSourceFile$mh`.invokeExact(
    `$p0`,
    client_data,
    index_callbacks,
    index_callbacks_size.toInt(),
    index_options.toInt(),
    source_filename,
    command_line_args,
    num_command_line_args,
    unsaved_files,
    num_unsaved_files.toInt(),
    out_TU,
    TU_options.toInt(),
) as Int

/**
 *
 * Same as clang_indexSourceFile but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */
public fun clang_indexSourceFileFullArgv(
    `$p0`: CXIndexAction,
    client_data: CXClientData,
    index_callbacks: Pointer<IndexerCallbacks>,
    index_callbacks_size: UInt,
    index_options: UInt,
    source_filename: Pointer<Byte>,
    command_line_args: Pointer<Pointer<Byte>>,
    num_command_line_args: Int,
    unsaved_files: Pointer<CXUnsavedFile>,
    num_unsaved_files: UInt,
    out_TU: Pointer<CXTranslationUnit>,
    TU_options: UInt,
): Int = `clang_indexSourceFileFullArgv$mh`.invokeExact(
    `$p0`,
    client_data,
    index_callbacks,
    index_callbacks_size.toInt(),
    index_options.toInt(),
    source_filename,
    command_line_args,
    num_command_line_args,
    unsaved_files,
    num_unsaved_files.toInt(),
    out_TU,
    TU_options.toInt(),
) as Int

/**
 *
 * Index the given translation unit via callbacks implemented through
 * #IndexerCallbacks.
 *
 * The order of callback invocations is not guaranteed to be the same as
 * when indexing a source file. The high level order will be:
 *
 * -Preprocessor callbacks invocations
 * -Declaration/reference callbacks invocations
 * -Diagnostic callback invocations
 *
 * The parameters are the same as #clang_indexSourceFile.
 *
 * \returns If there is a failure from which there is no recovery, returns
 * non-zero, otherwise returns 0.
 */
public fun clang_indexTranslationUnit(
    `$p0`: CXIndexAction,
    client_data: CXClientData,
    index_callbacks: Pointer<IndexerCallbacks>,
    index_callbacks_size: UInt,
    index_options: UInt,
    `$p5`: CXTranslationUnit,
): Int = `clang_indexTranslationUnit$mh`.invokeExact(
    `$p0`,
    client_data,
    index_callbacks,
    index_callbacks_size.toInt(),
    index_options.toInt(),
    `$p5`,
) as Int

/**
 *
 * Retrieve the CXIdxFile, file, line, column, and offset represented by
 * the given CXIdxLoc.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion and if it refers into a macro argument
 * retrieves the location of the argument.
 */
public fun clang_indexLoc_getFileLocation(
    loc: CXIdxLoc,
    indexFile: Pointer<CXIdxClientFile>,
    `file`: Pointer<CXFile>,
    line: Pointer<UInt>,
    column: Pointer<UInt>,
    offset: Pointer<UInt>,
): Unit = `clang_indexLoc_getFileLocation$mh`.invokeExact(loc.`$mem`, indexFile, `file`, line, column, offset) as Unit

/**
 *
 * Retrieve the CXSourceLocation represented by the given CXIdxLoc.
 */
context(SegmentAllocator)
public fun clang_indexLoc_getCXSourceLocation(loc: CXIdxLoc): CXSourceLocation = CXSourceLocation(
    `clang_indexLoc_getCXSourceLocation$mh`.invokeExact(
        this@SegmentAllocator,
        loc.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Visit the fields of a particular type.
 *
 * This function visits all the direct fields of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited field. The traversal may be ended prematurely, if
 * the visitor returns \c CXFieldVisit_Break.
 *
 * \param T the record type whose field may be visited.
 *
 * \param visitor the visitor function that will be invoked for each
 * field of \p T.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXFieldVisit_Break.
 */
public fun clang_Type_visitFields(
    T: CXType,
    visitor: CXFieldVisitor,
    client_data: CXClientData,
): UInt = (`clang_Type_visitFields$mh`.invokeExact(T.`$mem`, visitor, client_data) as Int).toUInt()

/**
 *
 * Retrieve the spelling of a given CXBinaryOperatorKind.
 */
context(SegmentAllocator)
public fun clang_getBinaryOperatorKindSpelling(kind: CXBinaryOperatorKind): CXString =
    CXString(`clang_getBinaryOperatorKindSpelling$mh`.invokeExact(this@SegmentAllocator, kind.value) as MemorySegment)

/**
 *
 * Retrieve the binary operator kind of this cursor.
 *
 * If this cursor is not a binary operator then returns Invalid.
 */
public fun clang_getCursorBinaryOperatorKind(cursor: CXCursor): CXBinaryOperatorKind =
    CXBinaryOperatorKind.fromInt(`clang_getCursorBinaryOperatorKind$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Retrieve the spelling of a given CXUnaryOperatorKind.
 */
context(SegmentAllocator)
public fun clang_getUnaryOperatorKindSpelling(kind: CXUnaryOperatorKind): CXString =
    CXString(`clang_getUnaryOperatorKindSpelling$mh`.invokeExact(this@SegmentAllocator, kind.value) as MemorySegment)

/**
 *
 * Retrieve the unary operator kind of this cursor.
 *
 * If this cursor is not a unary operator then returns Invalid.
 */
public fun clang_getCursorUnaryOperatorKind(cursor: CXCursor): CXUnaryOperatorKind =
    CXUnaryOperatorKind.fromInt(`clang_getCursorUnaryOperatorKind$mh`.invokeExact(cursor.`$mem`) as Int)

/**
 *
 * Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated parsed comment as a
 * \c CXComment_FullComment AST node.
 */
context(SegmentAllocator)
public fun clang_Cursor_getParsedComment(C: CXCursor): CXComment =
    CXComment(`clang_Cursor_getParsedComment$mh`.invokeExact(this@SegmentAllocator, C.`$mem`) as MemorySegment)

/**
 *
 * \param Comment AST node of any kind.
 *
 * \returns the type of the AST node.
 */
public fun clang_Comment_getKind(Comment: CXComment): CXCommentKind =
    CXCommentKind.fromInt(`clang_Comment_getKind$mh`.invokeExact(Comment.`$mem`) as Int)

/**
 *
 * \param Comment AST node of any kind.
 *
 * \returns number of children of the AST node.
 */
public fun clang_Comment_getNumChildren(Comment: CXComment): UInt =
    (`clang_Comment_getNumChildren$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment AST node of any kind.
 *
 * \param ChildIdx child index (zero-based).
 *
 * \returns the specified child of the AST node.
 */
context(SegmentAllocator)
public fun clang_Comment_getChild(Comment: CXComment, ChildIdx: UInt): CXComment = CXComment(
    `clang_Comment_getChild$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
        ChildIdx.toInt(),
    ) as MemorySegment
)

/**
 *
 * A \c CXComment_Paragraph node is considered whitespace if it contains
 * only \c CXComment_Text nodes that are empty or whitespace.
 *
 * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are
 * never considered whitespace.
 *
 * \returns non-zero if \c Comment is whitespace.
 */
public fun clang_Comment_isWhitespace(Comment: CXComment): UInt =
    (`clang_Comment_isWhitespace$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \returns non-zero if \c Comment is inline content and has a newline
 * immediately following it in the comment text.  Newlines between paragraphs
 * do not count.
 */
public fun clang_InlineContentComment_hasTrailingNewline(Comment: CXComment): UInt =
    (`clang_InlineContentComment_hasTrailingNewline$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_Text AST node.
 *
 * \returns text contained in the AST node.
 */
context(SegmentAllocator)
public fun clang_TextComment_getText(Comment: CXComment): CXString =
    CXString(`clang_TextComment_getText$mh`.invokeExact(this@SegmentAllocator, Comment.`$mem`) as MemorySegment)

/**
 *
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns name of the inline command.
 */
context(SegmentAllocator)
public fun clang_InlineCommandComment_getCommandName(Comment: CXComment): CXString = CXString(
    `clang_InlineCommandComment_getCommandName$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns the most appropriate rendering mode, chosen on command
 * semantics in Doxygen.
 */
public fun clang_InlineCommandComment_getRenderKind(Comment: CXComment): CXCommentInlineCommandRenderKind =
    CXCommentInlineCommandRenderKind.fromInt(`clang_InlineCommandComment_getRenderKind$mh`.invokeExact(Comment.`$mem`) as Int)

/**
 *
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns number of command arguments.
 */
public fun clang_InlineCommandComment_getNumArgs(Comment: CXComment): UInt =
    (`clang_InlineCommandComment_getNumArgs$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified argument.
 */
context(SegmentAllocator)
public fun clang_InlineCommandComment_getArgText(Comment: CXComment, ArgIdx: UInt): CXString = CXString(
    `clang_InlineCommandComment_getArgText$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
        ArgIdx.toInt(),
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns HTML tag name.
 */
context(SegmentAllocator)
public fun clang_HTMLTagComment_getTagName(Comment: CXComment): CXString =
    CXString(`clang_HTMLTagComment_getTagName$mh`.invokeExact(this@SegmentAllocator, Comment.`$mem`) as MemorySegment)

/**
 *
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns non-zero if tag is self-closing (for example, &lt;br /&gt;).
 */
public fun clang_HTMLStartTagComment_isSelfClosing(Comment: CXComment): UInt =
    (`clang_HTMLStartTagComment_isSelfClosing$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns number of attributes (name-value pairs) attached to the start tag.
 */
public fun clang_HTMLStartTag_getNumAttrs(Comment: CXComment): UInt =
    (`clang_HTMLStartTag_getNumAttrs$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns name of the specified attribute.
 */
context(SegmentAllocator)
public fun clang_HTMLStartTag_getAttrName(Comment: CXComment, AttrIdx: UInt): CXString = CXString(
    `clang_HTMLStartTag_getAttrName$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
        AttrIdx.toInt(),
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns value of the specified attribute.
 */
context(SegmentAllocator)
public fun clang_HTMLStartTag_getAttrValue(Comment: CXComment, AttrIdx: UInt): CXString = CXString(
    `clang_HTMLStartTag_getAttrValue$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
        AttrIdx.toInt(),
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns name of the block command.
 */
context(SegmentAllocator)
public fun clang_BlockCommandComment_getCommandName(Comment: CXComment): CXString = CXString(
    `clang_BlockCommandComment_getCommandName$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns number of word-like arguments.
 */
public fun clang_BlockCommandComment_getNumArgs(Comment: CXComment): UInt =
    (`clang_BlockCommandComment_getNumArgs$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified word-like argument.
 */
context(SegmentAllocator)
public fun clang_BlockCommandComment_getArgText(Comment: CXComment, ArgIdx: UInt): CXString = CXString(
    `clang_BlockCommandComment_getArgText$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
        ArgIdx.toInt(),
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_BlockCommand or
 * \c CXComment_VerbatimBlockCommand AST node.
 *
 * \returns paragraph argument of the block command.
 */
context(SegmentAllocator)
public fun clang_BlockCommandComment_getParagraph(Comment: CXComment): CXComment = CXComment(
    `clang_BlockCommandComment_getParagraph$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter name.
 */
context(SegmentAllocator)
public fun clang_ParamCommandComment_getParamName(Comment: CXComment): CXString = CXString(
    `clang_ParamCommandComment_getParamName$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the function prototype and \c clang_ParamCommandComment_getParamIndex
 * function will return a meaningful value.
 */
public fun clang_ParamCommandComment_isParamIndexValid(Comment: CXComment): UInt =
    (`clang_ParamCommandComment_isParamIndexValid$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns zero-based parameter index in function prototype.
 */
public fun clang_ParamCommandComment_getParamIndex(Comment: CXComment): UInt =
    (`clang_ParamCommandComment_getParamIndex$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if parameter passing direction was specified explicitly in
 * the comment.
 */
public fun clang_ParamCommandComment_isDirectionExplicit(Comment: CXComment): UInt =
    (`clang_ParamCommandComment_isDirectionExplicit$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter passing direction.
 */
public fun clang_ParamCommandComment_getDirection(Comment: CXComment): CXCommentParamPassDirection =
    CXCommentParamPassDirection.fromInt(`clang_ParamCommandComment_getDirection$mh`.invokeExact(Comment.`$mem`) as Int)

/**
 *
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns template parameter name.
 */
context(SegmentAllocator)
public fun clang_TParamCommandComment_getParamName(Comment: CXComment): CXString = CXString(
    `clang_TParamCommandComment_getParamName$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the template parameter list and
 * \c clang_TParamCommandComment_getDepth and
 * \c clang_TParamCommandComment_getIndex functions will return a meaningful
 * value.
 */
public fun clang_TParamCommandComment_isParamPositionValid(Comment: CXComment): UInt =
    (`clang_TParamCommandComment_isParamPositionValid$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based nesting depth of this parameter in the template parameter list.
 *
 * For example,
 * \verbatim
 * template<typename C, template<typename T> class TT>
 * void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0,
 * for T nesting depth is 1.
 */
public fun clang_TParamCommandComment_getDepth(Comment: CXComment): UInt =
    (`clang_TParamCommandComment_getDepth$mh`.invokeExact(Comment.`$mem`) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based parameter index in the template parameter list at a
 * given nesting depth.
 *
 * For example,
 * \verbatim
 * template<typename C, template<typename T> class TT>
 * void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0, so we can ask for index at depth 0:
 * at depth 0 C's index is 0, TT's index is 1.
 *
 * For T nesting depth is 1, so we can ask for index at depth 0 and 1:
 * at depth 0 T's index is 1 (same as TT's),
 * at depth 1 T's index is 0.
 */
public fun clang_TParamCommandComment_getIndex(Comment: CXComment, Depth: UInt): UInt =
    (`clang_TParamCommandComment_getIndex$mh`.invokeExact(Comment.`$mem`, Depth.toInt()) as Int).toUInt()

/**
 *
 * \param Comment a \c CXComment_VerbatimBlockLine AST node.
 *
 * \returns text contained in the AST node.
 */
context(SegmentAllocator)
public fun clang_VerbatimBlockLineComment_getText(Comment: CXComment): CXString = CXString(
    `clang_VerbatimBlockLineComment_getText$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * \param Comment a \c CXComment_VerbatimLine AST node.
 *
 * \returns text contained in the AST node.
 */
context(SegmentAllocator)
public fun clang_VerbatimLineComment_getText(Comment: CXComment): CXString = CXString(
    `clang_VerbatimLineComment_getText$mh`.invokeExact(
        this@SegmentAllocator,
        Comment.`$mem`,
    ) as MemorySegment
)

/**
 *
 * Convert an HTML tag AST node to string.
 *
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns string containing an HTML tag.
 */
context(SegmentAllocator)
public fun clang_HTMLTagComment_getAsString(Comment: CXComment): CXString =
    CXString(`clang_HTMLTagComment_getAsString$mh`.invokeExact(this@SegmentAllocator, Comment.`$mem`) as MemorySegment)

/**
 *
 * Convert a given full parsed comment to an HTML fragment.
 *
 * Specific details of HTML layout are subject to change.  Don't try to parse
 * this HTML back into an AST, use other APIs instead.
 *
 * Currently the following CSS classes are used:
 * \li "para-brief" for \paragraph and equivalent commands;
 * \li "para-returns" for \\returns paragraph and equivalent commands;
 * \li "word-returns" for the "Returns" word in \\returns paragraph.
 *
 * Function argument documentation is rendered as a \<dl\> list with arguments
 * sorted in function prototype order.  CSS classes used:
 * \li "param-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if
 * parameter index is invalid.
 *
 * Template parameter documentation is rendered as a \<dl\> list with
 * parameters sorted in template parameter list order.  CSS classes used:
 * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for
 * names inside template template parameters;
 * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if
 * parameter position is invalid.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an HTML fragment.
 */
context(SegmentAllocator)
public fun clang_FullComment_getAsHTML(Comment: CXComment): CXString =
    CXString(`clang_FullComment_getAsHTML$mh`.invokeExact(this@SegmentAllocator, Comment.`$mem`) as MemorySegment)

/**
 *
 * Convert a given full parsed comment to an XML document.
 *
 * A Relax NG schema for the XML can be found in comment-xml-schema.rng file
 * inside clang source tree.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an XML document.
 */
context(SegmentAllocator)
public fun clang_FullComment_getAsXML(Comment: CXComment): CXString =
    CXString(`clang_FullComment_getAsXML$mh`.invokeExact(this@SegmentAllocator, Comment.`$mem`) as MemorySegment)

/**
 *
 * Traverses the translation unit to create a \c CXAPISet.
 *
 * \param tu is the \c CXTranslationUnit to build the \c CXAPISet for.
 *
 * \param out_api is a pointer to the output of this function. It is needs to be
 * disposed of by calling clang_disposeAPISet.
 *
 * \returns Error code indicating success or failure of the APISet creation.
 */
public fun clang_createAPISet(tu: CXTranslationUnit, out_api: Pointer<CXAPISet>): CXErrorCode =
    CXErrorCode.fromInt(`clang_createAPISet$mh`.invokeExact(tu, out_api) as Int)

/**
 *
 * Dispose of an APISet.
 *
 * The provided \c CXAPISet can not be used after this function is called.
 */
public fun clang_disposeAPISet(api: CXAPISet): Unit = `clang_disposeAPISet$mh`.invokeExact(api) as Unit

/**
 *
 * Generate a single symbol symbol graph for the given USR. Returns a null
 * string if the associated symbol can not be found in the provided \c CXAPISet.
 *
 * The output contains the symbol graph as well as some additional information
 * about related symbols.
 *
 * \param usr is a string containing the USR of the symbol to generate the
 * symbol graph for.
 *
 * \param api the \c CXAPISet to look for the symbol in.
 *
 * \returns a string containing the serialized symbol graph representation for
 * the symbol being queried or a null string if it can not be found in the
 * APISet.
 */
context(SegmentAllocator)
public fun clang_getSymbolGraphForUSR(usr: Pointer<Byte>, api: CXAPISet): CXString =
    CXString(`clang_getSymbolGraphForUSR$mh`.invokeExact(this@SegmentAllocator, usr, api) as MemorySegment)

/**
 *
 * Generate a single symbol symbol graph for the declaration at the given
 * cursor. Returns a null string if the AST node for the cursor isn't a
 * declaration.
 *
 * The output contains the symbol graph as well as some additional information
 * about related symbols.
 *
 * \param cursor the declaration for which to generate the single symbol symbol
 * graph.
 *
 * \returns a string containing the serialized symbol graph representation for
 * the symbol being queried or a null string if it can not be found in the
 * APISet.
 */
context(SegmentAllocator)
public fun clang_getSymbolGraphForCursor(cursor: CXCursor): CXString =
    CXString(`clang_getSymbolGraphForCursor$mh`.invokeExact(this@SegmentAllocator, cursor.`$mem`) as MemorySegment)

/**
 *
 * Installs error handler that prints error message to stderr and calls abort().
 * Replaces currently installed error handler (if any).
 */
public fun clang_install_aborting_llvm_fatal_error_handler(): Unit =
    `clang_install_aborting_llvm_fatal_error_handler$mh`.invokeExact() as Unit

/**
 *
 * Removes currently installed error handler (if any).
 * If no error handler is intalled, the default strategy is to print error
 * message to stderr and call exit(1).
 */
public fun clang_uninstall_llvm_fatal_error_handler(): Unit =
    `clang_uninstall_llvm_fatal_error_handler$mh`.invokeExact() as Unit

/**
 *
 * Create CXRewriter.
 */
public fun clang_CXRewriter_create(TU: CXTranslationUnit): CXRewriter =
    `clang_CXRewriter_create$mh`.invokeExact(TU) as MemorySegment

/**
 *
 * Insert the specified string at the specified location in the original buffer.
 */
public fun clang_CXRewriter_insertTextBefore(
    Rew: CXRewriter,
    Loc: CXSourceLocation,
    Insert: Pointer<Byte>,
): Unit = `clang_CXRewriter_insertTextBefore$mh`.invokeExact(Rew, Loc.`$mem`, Insert) as Unit

/**
 *
 * Replace the specified range of characters in the input with the specified
 * replacement.
 */
public fun clang_CXRewriter_replaceText(
    Rew: CXRewriter,
    ToBeReplaced: CXSourceRange,
    Replacement: Pointer<Byte>,
): Unit = `clang_CXRewriter_replaceText$mh`.invokeExact(Rew, ToBeReplaced.`$mem`, Replacement) as Unit

/**
 *
 * Remove the specified range.
 */
public fun clang_CXRewriter_removeText(Rew: CXRewriter, ToBeRemoved: CXSourceRange): Unit =
    `clang_CXRewriter_removeText$mh`.invokeExact(Rew, ToBeRemoved.`$mem`) as Unit

/**
 *
 * Save all changed files to disk.
 * Returns 1 if any files were not saved successfully, returns 0 otherwise.
 */
public fun clang_CXRewriter_overwriteChangedFiles(Rew: CXRewriter): Int =
    `clang_CXRewriter_overwriteChangedFiles$mh`.invokeExact(Rew) as Int

/**
 *
 * Write out rewritten version of the main file to stdout.
 */
public fun clang_CXRewriter_writeMainFileToStdOut(Rew: CXRewriter): Unit =
    `clang_CXRewriter_writeMainFileToStdOut$mh`.invokeExact(Rew) as Unit

/**
 *
 * Free the given CXRewriter.
 */
public fun clang_CXRewriter_dispose(Rew: CXRewriter): Unit = `clang_CXRewriter_dispose$mh`.invokeExact(Rew) as Unit
