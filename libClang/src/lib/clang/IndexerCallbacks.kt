// this file is auto generated by endoqa kotlin ffi, modify it with caution
package lib.clang

import java.lang.foreign.*
import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.VarHandle

@JvmInline
public value class IndexerCallbacks(
    public val `$mem`: MemorySegment,
) {
    public var abortQuery: Pointer<(client_data: CXClientData, reserved: Pointer<Unit>) -> Int>
        get() = abortQueryHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            abortQueryHandle.set(this.`$mem`, 0L, value)
        }

    public var diagnostic: Pointer<(
        client_data: CXClientData,
        `$p1`: CXDiagnosticSet,
        reserved: Pointer<Unit>,
    ) -> Unit>
        get() = diagnosticHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            diagnosticHandle.set(this.`$mem`, 0L, value)
        }

    public var enteredMainFile: Pointer<(
        client_data: CXClientData,
        mainFile: CXFile,
        reserved: Pointer<Unit>,
    ) -> CXIdxClientFile>
        get() = enteredMainFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            enteredMainFileHandle.set(this.`$mem`, 0L, value)
        }

    public var ppIncludedFile:
            Pointer<(client_data: CXClientData, `$p1`: Pointer<CXIdxIncludedFileInfo>) -> CXIdxClientFile>
        get() = ppIncludedFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            ppIncludedFileHandle.set(this.`$mem`, 0L, value)
        }

    public var importedASTFile:
            Pointer<(client_data: CXClientData, `$p1`: Pointer<CXIdxImportedASTFileInfo>) -> CXIdxClientASTFile>
        get() = importedASTFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            importedASTFileHandle.set(this.`$mem`, 0L, value)
        }

    public var startedTranslationUnit:
            Pointer<(client_data: CXClientData, reserved: Pointer<Unit>) -> CXIdxClientContainer>
        get() = startedTranslationUnitHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            startedTranslationUnitHandle.set(this.`$mem`, 0L, value)
        }

    public var indexDeclaration:
            Pointer<(client_data: CXClientData, `$p1`: Pointer<CXIdxDeclInfo>) -> Unit>
        get() = indexDeclarationHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            indexDeclarationHandle.set(this.`$mem`, 0L, value)
        }

    public var indexEntityReference:
            Pointer<(client_data: CXClientData, `$p1`: Pointer<CXIdxEntityRefInfo>) -> Unit>
        get() = indexEntityReferenceHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            indexEntityReferenceHandle.set(this.`$mem`, 0L, value)
        }

    public constructor(gc: Boolean) : this(kotlin.run {
        require(gc) { "Do not call this if gc is not want" }
        Arena.ofAuto().allocate(layout)
    })

    public companion object {
        public val layout: StructLayout = MemoryLayout.structLayout(
            `$RuntimeHelper`.POINTER.withName("abortQuery"),
            `$RuntimeHelper`.POINTER.withName("diagnostic"),
            `$RuntimeHelper`.POINTER.withName("enteredMainFile"),
            `$RuntimeHelper`.POINTER.withName("ppIncludedFile"),
            `$RuntimeHelper`.POINTER.withName("importedASTFile"),
            `$RuntimeHelper`.POINTER.withName("startedTranslationUnit"),
            `$RuntimeHelper`.POINTER.withName("indexDeclaration"),
            `$RuntimeHelper`.POINTER.withName("indexEntityReference"),
        ).withName("IndexerCallbacks")

        @JvmField
        public val abortQueryHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("abortQuery"))

        @JvmField
        public val diagnosticHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("diagnostic"))

        @JvmField
        public val enteredMainFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("enteredMainFile"))

        @JvmField
        public val ppIncludedFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("ppIncludedFile"))

        @JvmField
        public val importedASTFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("importedASTFile"))

        @JvmField
        public val startedTranslationUnitHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("startedTranslationUnit"))

        @JvmField
        public val indexDeclarationHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("indexDeclaration"))

        @JvmField
        public val indexEntityReferenceHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("indexEntityReference"))

        @JvmStatic
        public fun allocate(alloc: SegmentAllocator): IndexerCallbacks =
            IndexerCallbacks(alloc.allocate(layout))

        /**
         *
         * A group of callbacks used by #clang_indexSourceFile and
         * #clang_indexTranslationUnit.
         */
        public fun interface abortQuery {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, reserved: Pointer<Unit>): Int

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(abortQuery::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.of(
                    ValueLayout.JAVA_INT,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface diagnostic {
            @CFunctionInvoke
            public fun invoke(
                client_data: CXClientData,
                `$p1`: CXDiagnosticSet,
                reserved: Pointer<Unit>,
            )

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(diagnostic::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface enteredMainFile {
            @CFunctionInvoke
            public fun invoke(
                client_data: CXClientData,
                mainFile: CXFile,
                reserved: Pointer<Unit>,
            ): CXIdxClientFile

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(enteredMainFile::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface ppIncludedFile {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxIncludedFileInfo>): CXIdxClientFile

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(ppIncludedFile::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface importedASTFile {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxImportedASTFileInfo>): CXIdxClientASTFile

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(importedASTFile::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface startedTranslationUnit {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, reserved: Pointer<Unit>): CXIdxClientContainer

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(startedTranslationUnit::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface indexDeclaration {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxDeclInfo>)

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(indexDeclaration::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        public fun interface indexEntityReference {
            @CFunctionInvoke
            public fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxEntityRefInfo>)

            public fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            public companion object {
                @JvmStatic
                public val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(indexEntityReference::class.java.methods.find {
                        it.getAnnotation(CFunctionInvoke::class.java) != null
                    }
                    )

                @JvmStatic
                public val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }
    }
}
