// this file is auto generated by endoqa kotlin ffi, modify it with caution
package lib.clang

import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.MethodType
import kotlin.Int

public enum class CXNameRefFlags(
    public val `value`: Int,
) {
    /**
     *
     * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
     * range.
     */
    WantQualifier(0x1),

    /**
     *
     * Include the explicit template arguments, e.g. \<int> in x.f<int>,
     * in the range.
     */
    WantTemplateArgs(0x2),

    /**
     *
     * If the name is non-contiguous, return the full spanning range.
     *
     * Non-contiguous names occur in Objective-C when a selector with two or more
     * parameters is used, or in C++ when using an operator:
     * \code
     * [object doSomething:here withValue:there]; // Objective-C
     * return some_vector[1]; // C++
     * \endcode
     */
    WantSinglePiece(0x4),
    ;

    public companion object {
        @JvmStatic
        public val fromInt: MethodHandle = MethodHandles.lookup().findStatic(
            CXNameRefFlags::class.java,
            "fromInt",
            MethodType.methodType(CXNameRefFlags::class.java, Int::class.java)
        )

        @JvmStatic
        public val toInt: MethodHandle = MethodHandles.lookup().findGetter(
            CXNameRefFlags::class.java,
            "value",
            Int::class.java
        )

        @JvmStatic
        public fun fromInt(`value`: Int): CXNameRefFlags = when (value) {
            WantQualifier.value -> WantQualifier
            WantTemplateArgs.value -> WantTemplateArgs
            WantSinglePiece.value -> WantSinglePiece
            else -> error("enum not found")
        }
    }
}
