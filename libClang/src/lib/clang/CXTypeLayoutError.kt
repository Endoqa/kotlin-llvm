// this file is auto generated by endoqa kotlin ffi, modify it with caution
package lib.clang

import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.MethodType
import kotlin.Int

/**
 *
 * List the possible error codes for \c clang_Type_getSizeOf,
 * \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and
 * \c clang_Cursor_getOffsetOf.
 *
 * A value of this enumeration type can be returned if the target type is not
 * a valid argument to sizeof, alignof or offsetof.
 */
public enum class CXTypeLayoutError(
    public val `value`: Int,
) {
    /**
     *
     * Type is of kind CXType_Invalid.
     */
    Invalid(-1),

    /**
     *
     * The type is an incomplete Type.
     */
    Incomplete(-2),

    /**
     *
     * The type is a dependent Type.
     */
    Dependent(-3),

    /**
     *
     * The type is not a constant size type.
     */
    NotConstantSize(-4),

    /**
     *
     * The Field name is not valid for this record.
     */
    InvalidFieldName(-5),

    /**
     *
     * The type is undeduced.
     */
    Undeduced(-6),
    ;

    public companion object {
        @JvmStatic
        public val fromInt: MethodHandle = MethodHandles.lookup().findStatic(
            CXTypeLayoutError::class.java,
            "fromInt",
            MethodType.methodType(CXTypeLayoutError::class.java, Int::class.java)
        )

        @JvmStatic
        public val toInt: MethodHandle = MethodHandles.lookup().findGetter(
            CXTypeLayoutError::class.java,
            "value",
            Int::class.java
        )

        @JvmStatic
        public fun fromInt(`value`: Int): CXTypeLayoutError = when (value) {
            Invalid.value -> Invalid
            Incomplete.value -> Incomplete
            Dependent.value -> Dependent
            NotConstantSize.value -> NotConstantSize
            InvalidFieldName.value -> InvalidFieldName
            Undeduced.value -> Undeduced
            else -> error("enum not found")
        }
    }
}
