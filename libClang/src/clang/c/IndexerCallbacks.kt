// this file is auto generated by endoqa kotlin ffi, modify it with caution
package clang.c

import java.lang.foreign.*
import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.VarHandle

@JvmInline
value class IndexerCallbacks(
    val `$mem`: MemorySegment,
) {
    var abortQuery: Pointer<(client_data: CXClientData, reserved: Pointer<Unit>) -> Int>
        get() = abortQueryHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            abortQueryHandle.set(this.`$mem`, 0L, value)
        }

    var diagnostic: Pointer<(
        client_data: CXClientData,
        `$p1`: CXDiagnosticSet,
        reserved: Pointer<Unit>,
    ) -> Unit>
        get() = diagnosticHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            diagnosticHandle.set(this.`$mem`, 0L, value)
        }

    var enteredMainFile: Pointer<(
        client_data: CXClientData,
        mainFile: CXFile,
        reserved: Pointer<Unit>,
    ) -> CXIdxClientFile>
        get() = enteredMainFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            enteredMainFileHandle.set(this.`$mem`, 0L, value)
        }

    var ppIncludedFile: Pointer<(
        client_data: CXClientData,
        `$p1`: Pointer<CXIdxIncludedFileInfo>
    ) -> CXIdxClientFile>
        get() = ppIncludedFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            ppIncludedFileHandle.set(this.`$mem`, 0L, value)
        }

    var importedASTFile: Pointer<(
        client_data: CXClientData,
        `$p1`: Pointer<CXIdxImportedASTFileInfo>
    ) -> CXIdxClientASTFile>
        get() = importedASTFileHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            importedASTFileHandle.set(this.`$mem`, 0L, value)
        }

    var startedTranslationUnit: Pointer<(
        client_data: CXClientData,
        reserved: Pointer<Unit>
    ) -> CXIdxClientContainer>
        get() = startedTranslationUnitHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            startedTranslationUnitHandle.set(this.`$mem`, 0L, value)
        }

    var indexDeclaration: Pointer<(
        client_data: CXClientData,
        `$p1`: Pointer<CXIdxDeclInfo>
    ) -> Unit>
        get() = indexDeclarationHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            indexDeclarationHandle.set(this.`$mem`, 0L, value)
        }

    var indexEntityReference: Pointer<(
        client_data: CXClientData,
        `$p1`: Pointer<CXIdxEntityRefInfo>
    ) -> Unit>
        get() = indexEntityReferenceHandle.get(this.`$mem`, 0L) as MemorySegment
        set(`value`) {
            indexEntityReferenceHandle.set(this.`$mem`, 0L, value)
        }

    constructor(gc: Boolean) : this(kotlin.run {
        require(gc) { "Do not call this if gc is not want" }
        Arena.ofAuto().allocate(layout)
    })

    companion object {
        val layout: StructLayout = MemoryLayout.structLayout(
            `$RuntimeHelper`.POINTER.withName("abortQuery"),
            `$RuntimeHelper`.POINTER.withName("diagnostic"),
            `$RuntimeHelper`.POINTER.withName("enteredMainFile"),
            `$RuntimeHelper`.POINTER.withName("ppIncludedFile"),
            `$RuntimeHelper`.POINTER.withName("importedASTFile"),
            `$RuntimeHelper`.POINTER.withName("startedTranslationUnit"),
            `$RuntimeHelper`.POINTER.withName("indexDeclaration"),
            `$RuntimeHelper`.POINTER.withName("indexEntityReference"),
        ).withName("IndexerCallbacks")

        @JvmField
        val abortQueryHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("abortQuery"))

        @JvmField
        val diagnosticHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("diagnostic"))

        @JvmField
        val enteredMainFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("enteredMainFile"))

        @JvmField
        val ppIncludedFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("ppIncludedFile"))

        @JvmField
        val importedASTFileHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("importedASTFile"))

        @JvmField
        val startedTranslationUnitHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("startedTranslationUnit"))

        @JvmField
        val indexDeclarationHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("indexDeclaration"))

        @JvmField
        val indexEntityReferenceHandle: VarHandle =
            layout.varHandle(MemoryLayout.PathElement.groupElement("indexEntityReference"))

        @JvmStatic
        fun allocate(alloc: SegmentAllocator): IndexerCallbacks =
            IndexerCallbacks(alloc.allocate(layout))

        fun interface abortQuery {
            fun invoke(client_data: CXClientData, reserved: Pointer<Unit>): Int

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(abortQuery::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.of(
                    ValueLayout.JAVA_INT,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface diagnostic {
            fun invoke(
                client_data: CXClientData,
                `$p1`: CXDiagnosticSet,
                reserved: Pointer<Unit>,
            )

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(diagnostic::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface enteredMainFile {
            fun invoke(
                client_data: CXClientData,
                mainFile: CXFile,
                reserved: Pointer<Unit>,
            ): CXIdxClientFile

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(enteredMainFile::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface ppIncludedFile {
            fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxIncludedFileInfo>):
                    CXIdxClientFile

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(ppIncludedFile::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface importedASTFile {
            fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxImportedASTFileInfo>):
                    CXIdxClientASTFile

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(importedASTFile::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface startedTranslationUnit {
            fun invoke(client_data: CXClientData, reserved: Pointer<Unit>): CXIdxClientContainer

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(startedTranslationUnit::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.of(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface indexDeclaration {
            fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxDeclInfo>)

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(indexDeclaration::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }

        fun interface indexEntityReference {
            fun invoke(client_data: CXClientData, `$p1`: Pointer<CXIdxEntityRefInfo>)

            fun allocate(arena: Arena): MemorySegment =
                Linker.nativeLinker().upcallStub(invokeHandle.bindTo(this), fd, arena)

            companion object {
                @JvmStatic
                val invokeHandle: MethodHandle =
                    MethodHandles.lookup().unreflect(indexEntityReference::class.java.methods.find {
                        it.name == "invoke"
                    }
                    )

                @JvmStatic
                val fd: FunctionDescriptor = FunctionDescriptor.ofVoid(
                    `$RuntimeHelper`.POINTER,
                    `$RuntimeHelper`.POINTER,
                )
            }
        }
    }
}
